# Docker技术

## Docker 教程

​	Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。
​	Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。
​	容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。

![docker 中文文档](https://static.coonote.com/docker_intro.png)

**相关链接**：[docker中文文档 (coonote.com)](https://www.coonote.com/docker/docker-tutorial.html)



## 容器部署发展简史

​	互联网企业生产环境的应用部署所经历的过程，大致可分三个阶段：

- 物理机部署
- 虚拟机部署
- 容器化部署

### 物理机部署时代

<img src="https://static.coonote.com/physical-machine.png" alt="物理机部署" style="zoom: 25%;" />

​	用纯粹的物理机部署应用，这是所有早期物联网公司必然经历的一个阶段。一台服务器，至少32核CPU、64G内存，如果只部署一个应用，那就太浪费了。于是，多个应用进程，DB，缓存进程等等都部署在同一个机器上。这样部署固然能高效的利用好昂贵的物理机，但是这种简单粗暴的方式有一个最大的痛点：进程间资源抢占。如果某个进程耗用了100%的CPU资源，其他的进程无法提供服务。或者如果一个进程因为突发异常很多，日志把磁盘打满了，所有的进程都要挂掉。进程间抢占资源导致其他进程无法提供服务所导致的血案数不胜数。这样的问题相信很多同学的遇到过。
  既然因为资源共享导致的问题，那么解决方式就是：进程间硬件资源隔离。虚拟机技术的出现解决了这个棘手的问题。

### 虚拟机部署时代

<img src="https://static.coonote.com/virtual-machine.png" alt="虚拟机部署" style="zoom:25%;" />

​	虚拟机通过硬件虚拟化，即每台虚拟机事先从物理机分配好cpu核数，内存， 磁盘，每台虚拟机一般只部署一个应用。从而解决了进程间资源隔离的问题。不同的进程在不同的虚拟机上跑，大家相安无事，老死不相往来，自然没有资源冲突。一台物理机会部署多台虚拟机，物理机里的所有虚拟机则依靠虚拟机管理系统进行管理。

  虚拟机技术解决了物理机部署的痛点。但是虚拟机并不是完美的，他也有自己的缺点。大集群部署情况下，软件的版本和配置文件容易碎片化。

  大应用集群的虚拟机第一次安装时，由于操作系统镜像是一样的，所以刚开始，软件的版本和库依赖是统一的。随着时间的推移，开源的软件（tomcat, jdk, nginx）需要逐步升级，于是运维同学开始批量升级集群的软件版本，批量升级可能有遗漏或升级失败。同时有些开发同学会自己登陆机器修改软件的版本或者配置，以满足自己的需求。长此以往，一个应用的集群的虚拟机的软件版本和配置逐渐碎片化。当线上出现问题，需要排查到基础软件层面时，由于软件版本碎片化的问题，导致排查变得很棘手。

  为了解决虚拟机部署的痛点，容器技术应运而生。

### 容器部署时代

<img src="https://static.coonote.com/container.png" alt="容器部署" style="zoom:25%;" />

​	容器技术不仅限于docker，但是docker目前最为流行，我以docker为例讲容器。docker容器技术的核心之一在于镜像文件。
镜像文件，通俗的理解就是一个进程运行时依赖的软件文件的集装箱。
  应用集群部署时，每台机器首先会拉取指定版本的镜像文件。安装镜像后产生了docker容器。由于所有机器的镜像文件一样，容器的软件版本故而一样。即使开发或运维中途修改了容器的软件版本，但是容器销毁时，软件的改动会随容器的销毁一起湮灭。当应用用已有的镜像文件重新部署时，生成的docker容器跟修改之前的容器完全一样。这也是Infrastructure as code思想带来的好处。

  容器如果要升级软件版本，那就修改镜像文件。这样部署时集群内所有的机器重新拉取新的镜像，软件因此跟着一起升级。软件版本混乱的问题，到docker这里，也就得到了完美的解决。

一个疑问：有了容器技术，生产环境为何还需要部署虚拟机？

虚拟机能做到硬件资源的彻底隔离，docker不行。虚拟机 和 docker各取长处，最佳CP。





## Docker 架构

要理解 Docker 的内部构建，必须知道Docker 包括三个基本概念:

- **镜像（Image）**：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。
- **容器（Container）**：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
- **仓库（Repository）**：仓库可看成一个代码控制中心，用来保存镜像。

Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器（从远程拉取镜像）。

Docker 容器通过 Docker 镜像来创建。

容器与镜像的关系类似于面向对象编程中的对象与类。

| Docker | 面向对象 |
| :----: | :------: |
|  容器  |   对象   |
|  镜像  |    类    |

<img src="https://static.coonote.com/docker-architecture.png" alt="Docker 架构图"  />

|          概念          |                             说明                             |
| :--------------------: | :----------------------------------------------------------: |
|  Docker 镜像(Images)   | Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。  |
| Docker 容器(Container) |     容器是独立运行的一个或一组应用，是镜像运行时的实体。     |
| Docker 客户端(Client)  | Docker 客户端通过命令行或者其他工具使用 Docker SDK (https://docs.docker.com/develop/sdk/) 与 Docker 的[守护进程](https://www.coonote.com/cplusplus-note/linux-daemons.html)通信。 |
|   Docker 主机(Host)    |    一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。    |
|    Docker Registry     | Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。 Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。 一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。 通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <仓库名>:<标签> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 |
|     Docker Machine     | Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 |



## Docker 底层技术

### Docker 底层的核心技术包括：

- Linux 上的名字空间（Namespaces）
- 控制组（Control groups）
- Union 文件系统（Union file systems）
- 容器格式（Container format）

### 名字空间

名字空间是 Linux 内核一个强大的特性。每个容器都有自己单独的名字空间，运行在其中的应用都像是在独立的操作系统中运行一样。名字空间保证了容器之间彼此互不影响。

- pid 名字空间

  不同用户的进程就是通过 pid 名字空间隔离开的，且不同名字空间中可以有相同 pid。所有的 LXC 进程在Docker 中的父进程为Docker进程，每个 LXC 进程具有不同的名字空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。

  

- net 名字空间
  有了 pid 名字空间, 每个名字空间中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net 名字空间实现的， 每个 net 名字空间有独立的 网络设备, IP 地址, 路由表, /proc/net 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker网桥 docker0 连接在一起。

  

- ipc 名字空间
  容器中进程交互还是采用了 Linux 常见的进程间交互方法(interprocess communication – IPC), 包括信号量、消息队列和共享内存等。然而同 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid 名字空间中的进程间交互，因此需要在 IPC 资源申请时加入名字空间信息，每个 IPC 资源有一个唯一的 32位 id。



- mnt 名字空间
  类似 chroot，将一个进程放到一个特定的目录执行。mnt 名字空间允许不同名字空间的进程看到的文件结构不同，这样每个名字空间 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个名字空间中的容器在 /proc/mounts 的信息只包含所在名字空间的 mount point。



- uts 名字空间
  UTS(“UNIX Time-sharing System”) 名字空间允许每个容器拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。



- user 名字空间
  每个容器可以有不同的用户和组 id, 也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。



### 控制组

控制组（cgroups）是 Linux 内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。

控制组技术最早是由 Google 的程序员 2006 年起提出，Linux 内核自 2.6.24 开始支持。

控制组可以提供对容器的内存、CPU、磁盘 IO 等资源的限制和审计管理。

### 联合文件系统

联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into asingle virtual filesystem)。

联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。

另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。

Docker 中使用的 AUFS（AnotherUnionFS）就是一种联合文件系统。 AUFS 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 AUFS 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。

Docker 目前支持的联合文件系统种类包括 AUFS, btrfs, vfs 和 DeviceMapper。

### 容器格式

最初，Docker 采用了 LXC 中的容器格式。自 1.20 版本开始，Docker 也开始支持新的 libcontainer 格式，并作为默认选项。

对更多容器格式的支持，还在进一步的发展中。



## Docker 网络实现

