# 吃豆人小游戏



## 1 游戏框架

- 初始化游戏
- 加载游戏资源
- 运行游戏
  - 更新游戏内容
  - 处理用户输入命令
  - 进行吃豆人移动
  - 判断碰撞情况
  - 检查运行情况
  - 终止游戏

```go
func main() {
	// initialize game

	// load resources

	// game loop
	for {
		// update screen

		// process input

		// process movement

		// process collisions

		// check game over

		// Temp: break infinite loop
		fmt.Println("Hello, Pac Go!")
		break

		// repeat
	}
}
```



## 2 加载地图资源

```go
// 存储地图资源的字符串
var maze []string

// 加载地图资源
func loadMaze(file string) error {
	// 打开地图文件
	f, err := os.Open(file)
	if err != nil {
		return err
	}
	defer f.Close()
	// 创建一个Scanner，
	// Scanner类型提供了方便的读取数据的接口，如从换行符分隔的文本里读取每一行。
	// NewScanner创建并返回一个从r读取数据的Scanner，默认的分割函数是ScanLines。
	scanner := bufio.NewScanner(f)
	// 读取游标
	for scanner.Scan() {
		// 返回Scan方法指向的行
		line := scanner.Text()
		maze = append(maze, line)
	}

	return nil
}

// 打印加载到maze的地图资源
func printScreen() {
	for _, line := range maze {
		fmt.Println(line)
	}
}
```



## 3 处理玩家输入

### 概述

在最后一步中，我们学习了如何将某些内容打印到标准输出。现在是时候学习如何从标准输入中读取了。

在这个游戏中，我们将处理一组有限的动作：向上、向下、向左和向右。除此之外，我们将使用的唯一其他键是转义键（如Esc），以使玩家能够优雅地退出游戏。移动将映射到箭头键。

### 终端模式简介

终端可以在三种可能的[模式下](https://en.wikipedia.org/wiki/Terminal_mode)运行：

1. Cooked Mode
2. Cbreak Mode
3. Raw Mode

`Cooked Mode`是我们习惯使用的模式。在这种模式下，终端接收的每个输入都经过预处理，这意味着系统会拦截特殊字符以赋予它们特殊含义。

注意：特殊字符包括退格键，删除，Ctrl + D，Ctrl + C，箭头键等...

`Raw Mode`正好相反：数据按原样传递，无需任何类型的预处理。

`Cbreak Mode`是中间地带。有些字符经过预处理，有些则没有。例如，`Ctrl+C`仍会导致程序流产，但箭头键将按经过处理传递给程序。

我们将使用 cbreak 模式来处理与转义键和箭头键相对应的转义序列。