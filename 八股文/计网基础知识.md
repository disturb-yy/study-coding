# 基础概念



## TCP/IP 网络模型有哪几层

TCP/IP 网络通常是由上到下分成 4 层，分别是**应用层，传输层，网络层和网络接口层**。

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202302072023866.png" alt="img" style="zoom:67%;" />

每一层的封装格式：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img" style="zoom:67%;" />

网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。





### 应用层

最上层的，也是我们能直接接触到的就是**应用层**（*Application Layer*），我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，**应用就把应用数据传给下一层**，也就是传输层。

所以，**应用层只需要专注于为用户提供应用功能**，比如 HTTP、FTP、Telnet、DNS、SMTP等。

**应用层是不用去关心数据是如何传输的**，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。

而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。



### 传输层

应用层的数据包会传给传输层，**传输层**（*Transport Layer*）是为<u>应用层提供网络支持的</u>。

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202302072000316.png" alt="img" style="zoom:67%;" />



在传输层会有两个传输协议，**分别是 TCP 和 UDP。**

**TCP 的全称叫传输控制协议（*Transmission Control Protocol*）**，大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如**流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对**方。

UDP 相对来说就很简单，**简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。**当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。

应用需要传输的数据可能会非常大，如果直接传输就不好控制，**因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包**。在 TCP 协议中，我们把每个分块称为一个 **TCP 段**（*TCP Segment*）。

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202302072012965.png" alt="img" style="zoom:67%;" />

当设备作为接收方时，传输层则要负责把数据包传给应用，<u>但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是**端口**。</u>

比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。

**由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。**



###  网络层

我们不希望传输层协议处理太多的事情，只需要服务好应用即可，**让其作为应用间数据传输的媒介，帮助实现应用到应用的通信（实现逻辑的传输功能）**，而实际的传输功能就交给下一层，也就是**网络层**（*Internet Layer*）。

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202302072014395.png" alt="img" style="zoom:67%;" />

网络层最常使用的是 IP 协议（*Internet Protocol*），<u>IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文</u>，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会**再次进行分片**，得到一个即将发送到网络的 IP 报文。

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202302072015386.png" alt="img" style="zoom:67%;" />



我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。

因此，需要将 IP 地址分成两种意义：

- 一个是**网络号**，负责标识该 IP 地址是属于哪个「子网」的；
- 一个是**主机号**，负责标识同一「子网」下的不同主机；

怎么分的呢？这需要配合**子网掩码**才能算出 IP 地址 的网络号和主机号。

那么在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。



除了寻址能力， IP 协议还有另一个重要的能力就是**路由**。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，**因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。**

**路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。**

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202302072017944.png" alt="IP地址的网络号" style="zoom:67%;" />

所以，**IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘（路线规划）**。



### 网络接口层

生成了 IP 头部之后，接下来要交给**网络接口层**（*Link Layer*）在 IP 头部的前面加上 MAC 头部，并封装成**数据帧（Data frame**）发送到网络上。

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202302072018806.png" alt="img" style="zoom:67%;" />

IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。

**什么是以太网呢？**电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。**以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。**

以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。

MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。

**所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。**













# 应用层



## HTTP 协议



### Cookies



#### Cookies是什么

- Cookies是浏览器访问服务器后，服务器传给浏览器的一段数据，**用于保存浏览器的身份信息**
- 浏览器要保存这段信息
- 浏览器每次访问服务器时，都要带上这段信息，用于服务器验证浏览器的身份信息



#### Cookies的作用

- 识别用户身份：当浏览器A访问服务器时，服务器返回响应时会携带一个uid=A的cookies，从而在A浏览该域名的其他页面时，识别出A的身份
- 持久化用户信息：可以保存用户的个人信息，用于给用户推送广告等服务

-----------------------



### Referrer Policy 和 Referrer

- Referrer：浏览器向服务器发送的Request报文中，会携带Referrer（HTTP请求其中一个报文头），用于指明当前流量的来源参考页面，表明浏览器如何来到当前页面（如查看百度搜索结果，会被告知其通过www.baidu.com跳转的），**即Referrer字段是用来指定该请求是从哪个页面跳转来的，该信息是由浏览器填的**。
- Referrer Policy：由于Referre会告知服务器用户的来源，所以第三方网站可以通过其获取用户的id和密码（对于将密码存储在url的网站来说），此时就可以通过Referrer Policy来控制第三方网站获取的信息。如strict-origin-when-cross-origin策略的含义是跨域名访问时，将当前页面的URL过滤掉参数及路径部分，仅将协议、端口和域名作为Referre传输。

-----------------



### Cache-control



#### 什么是Cache-control

Cache-control是一种缓存控制机制，**用于确定该用户是否从本地缓存中加载资源，还是向服务器发送新资源的请求**。



#### 什么浏览器缓存

浏览器访问服务器时，服务器会将一些静态资源先发送给浏览器，而浏览器会本地保存这些资源一段时间（限定资源的保存时间，称为**生存时间TTL，Time To Life**），**以便不需要再次通过网络获取它们**，这就是浏览器缓存。



#### 常见的缓存控制策略

- private：只能由客户端缓存
- public：可以由任何缓存
- no-store：无法缓存
- max-age：设置最大缓存时间
- no-cache：检查资源是否有无更新版本，如果没有，才可以使用所求资源的缓存版本



#### Etag (Entity tag)

服务器资源版本的令牌标识。通过HTTP响应头部将其发送给客户端，当资源更新时，该令牌会更新。当使用no-cache缓存机制时，浏览器会将已有的Etag发送给服务器，服务器拿到Etag，对比资源是否发生变化，从而决定是否将资源重新发送给浏览器。

- 如果资源未发生变化，返回**304HTTP状态码**，不返回具体的资源
- 如果资源发送变化，则浏览器需要下载新版本的资源

这样可以确保用户始终获取资源的最新版本，而无需进行不必要的下载。





# 传输层



## TCP 协议

TCP，传输控制协议（Transmission Control Protocol），是一种传输层的通信协议，具有以下三个特性：

- **面向连接**
- **可靠的**
- **基于字节流**



## 为什么要将数据切片

网络传输的数据大小是有限制的，这个是由**网络接口层（数据链路层）**提供的，一般认为是 **MTU(1500)**。因此，在传输数据的时候，当数据的大小超过网络传输的限制以后，就需要对传输的数据进行切片，变成一个个数据包。当使用TCP协议时，消息进入传输层以后会被切片为一个个数据包，这个数据包的长度就是MSS。



### MTU和MSS有什么区别



#### MTU (Maximum Transmit Unit) —— 最大传输单元

由**网络接口层（数据链路层）**提供给网络层最大一次传输数据的大小，一般*MTU=1500 Byte*。IP层分片后，每个分片的 IP Header ID 相同。



#### MSS (Maximum Segment Size) —— 最大分段大小

- MSS 是TCP 用来限制应用层最大发送字节数。

- TCP提供给 IP 层的最大分段大小，不包含TCP Header 和 Option，只包含 TCP Payload (有效载荷)。

假设 MTU = 1500 byte，那么MSS = 1500 - 20(IP Header) - 20(TCP Header) = 1460 byte，如果应用层有2000 byte 需要发送，那么就需要两个切片才能完成，第一个TCP切片的大小=1460，第二个切片大小=540



-----------

综合来说，IP层就是一个只知道搬运消息的摸鱼打工人。

----------------------



## 粘包



### 什么是粘包

B收到从A发送过来的消息切片，对其进行重组的时候，出现了错误的字节流信息。**即粘包就是：两个数据包的内容被错误地当成一个数据包的内容解析出来。**



### 为什么会出现粘包

TCP传输过程中出现粘包的很大原因就是**基于字节流**这个特点。

字节流：一大堆二进制数据，数据串之间没有边界。



### 为什么要组装发送的数据

TCP切片是为了顺利通过网络的这根水管，而组装（把前后两次数据远小于MSS的TCP组装起来）就是**为了减少网络IO的次数**。



#### Nagle 算法优化 —— delay 发送

Nagle算法就是一种组装的算法，其目的就是为了避免发送小的数据包。

在 Nagle 算法开启的情况下，数据包会在以下两种情况下发送：

- 如果包长度达到 MSS（或含有Fin包），就会立即发送；否则就会等待下一个包到来，如果到来后两个包的长度大于MSS，则会再次进行拆分发送。
- 等待超时（一般为200ms），第一个包没到 MSS 长度，但下一个包迟迟未到达，则会立即发送。





#### 关闭 Nagle算法就不会粘包吗

还是会粘包。虽然关闭 Nagle 算法，可以让数据包立即发送，不需要等待，但是接收方如果对发送的数据包未及时处理，还是会出现粘包现象。



### 怎么处理粘包



### UDP会粘包吗



### 为什么长度冗余字段还要加到UDP首部中



### IP层会有粘包问题吗





