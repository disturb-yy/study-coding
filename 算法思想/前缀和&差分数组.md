#### 1 数组中的前缀和

​	**含义**：数组 preix\[i] 代表前 i 项（包含i）的和   

​	**注意**：

- 可以获取阶段的数据，推荐设置0边界数组，提高计算的复用性
- 可以使用map来存储出现的前缀和，从而减少时间复杂度

#### 2 差分数组

​	**含义**：数组 diff\[i] 表示 nums\[i] 与 nums\[i-1] 之差

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/2.jpeg" alt="img" style="zoom: 33%;" />

​	**代码**：

```go
\\ 根据原数组构造差分数组
diff := make([]int, len(nums))
diff[0] = nums[0]
for i := 1; i < len(nums); i++ {
    diff[i] = nums[i] - nums[i-1]
}

\\ 根据差分数组还原原数组
res := make([]int, len(diff))
res[0] = diff[0]
for i := 1; i < len(diff); i++ {
    res[i] = res[i-1] + diff[i]
}
```

​	**使用情景**：

​	**这样构造差分数组 `diff`，就可以快速进行区间增减的操作**，如果你想对区间 `nums[i..j]` 的元素全部加 3，那么只需要让 `diff[i] += 3`，然后再让 `diff[j+1] -= 3` 即可：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/3.jpeg" alt="img" style="zoom: 33%;" />

​	**原理很简单，回想 `diff` 数组反推 `nums` 数组的过程，`diff[i] += 3` 意味着给 `nums[i..]` 所有的元素都加了 3，然后 `diff[j+1] -= 3` 又意味着对于 `nums[j+1..]` 所有元素再减 3，那综合起来，是不是就是对 `nums[i..j]` 中的所有元素都加 3 了**？

```go
// 差分接口的实现
type Difference struct {
	diff []int
}
type Differencer interface {
	increment(i, j int, val int)
	result() []int
}
func newDifference(nums []int) Difference {
	n := len(nums)
	diff := make([]int, n)
	if n == 0 {
		return Difference{diff}
	}
	diff[0] = nums[0]
	for i := 1; i < n; i++ {
		diff[i] = nums[i] - nums[i-1]
	}
	return Difference{diff}
}
func (this *Difference) increment(i, j int, val int) {
	this.diff[i] += val
	if j+1 < len(this.diff) {
		this.diff[j+1] -= val
	}
}
func (this *Difference) result() []int {
	q := this.diff
	res := make([]int, len(q))
	res[0] = q[0]
	for i := 1; i < len(q); i++ {
		res[i] = res[i-1] + q[i]
	}
	return res
}
```







**注意**：

- 推荐设置边界，提高计算的复用性

