# 查找排序类算法

## 查找类算法

### 二分查找

#### 1、二分查找框架

```go
func binarySearch(nums []int, target int) int {
    left, right := 0, ...
    
    for ... {
        mid := left + (right-left)>>1
        if nums[mid] == target {
            ...
        } else if nums[mid] < target {
            left = ...
        } else if nums[mid] > target {
            right = ...
        }
    }
    return ...
}
```

- **分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节**。

- 其中 `...` 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。

- **另外提前说明一下，计算 `mid` 时需要防止溢出**，代码中 `left + (right - left) / 2` 就和 `(left + right) / 2` 的结果相同，但是有效防止了 `left` 和 `right` 太大，直接相加导致溢出的情况。



#### 2、二分搜索细节

##### 2.1 为什么 while 循环的条件中是 <=，而不是 <？

- 主要看**搜索区间**

- 因为初始化 `right` 的赋值是 `nums.length - 1`，即最后一个元素的索引，而不是 `nums.length`。如果`right`的赋值为`nums.length` ，则右边界是不需要取到的，此时就要用 `<`  。
- 这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 `[left, right]`，后者相当于左闭右开区间 `[left, right)`，因为索引大小为 `nums.length` 是越界的。

##### 2.2 为什么 `left = mid + 1`，`right = mid - 1`？我看有的代码是 `right = mid` 或者 `left = mid`，没有这些加加减减，到底怎么回事，怎么判断？

​	刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 `[left, right]`。那么当我们发现索引 `mid` 不是要找的 `target` 时，下一步应该去搜索哪里呢？

​	当然是去搜索区间 `[left, mid-1]` 或者区间 `[mid+1, right]` 对不对？**因为 `mid` 已经搜索过，应该从搜索区间中去除**。



#### 3、基本二分搜索 —— 寻找一个数

**题目**：[704. 二分查找](https://leetcode.cn/problems/binary-search/)

**思路**：

**1 搜索区间**：` [left, right] ` ——> ` <= `

​	`while(left <= right)` 的终止条件是 `left == right + 1`，写成区间的形式就是 `[right + 1, right]`，或者带个具体的数字进去 `[3, 2]`，可见**这时候区间为空**，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

​	`while(left < right)` 的终止条件是 `left == right`，写成区间的形式就是 `[right, right]`，或者带个具体的数字进去 `[2, 2]`，**这时候区间非空**，还有一个数 2，但此时 while 循环终止了。也就是说这区间 `[2, 2]` 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。

**2 left = mid + ?**

​	由于搜索区间为` [left, right] `，当` mid `的值不是target值，我们就需要更新搜索区间，即` [left, mid-1]` 和 `[mid+1，right]`，因为` mid ` 已经搜索过了，所以不用再次搜索

**3 算法缺陷**

​	比如说给你有序数组 `nums = [1,2,2,2,3]`，`target` 为 2，此算法返回的索引是 2，没错。但是如果我想得到 `target` 的左侧边界，即索引 1，或者我想得到 `target` 的右侧边界，即索引 3，这样的话此算法是无法处理的。

​	这样的需求很常见，**你也许会说，找到一个 `target`，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了**。

**代码**：

```go
func binarySearch(nums []int, target int) int {
    left, right := 0, len(nums)-1
    
    for left <= right {
        mid := left + (right-left)>>1
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else if nums[mid] > target {
            right = mid - 1 
        }
    }
    return -1
}
```



#### 4、寻找左侧边界的二分搜索

**思路**：使用左闭右开区间

**1 为什么 while 中是 `<` 而不是 `<=`**?

​	因为搜索区间是` [left, right)`，其取不到边界

**2、为什么没有返回 -1 的操作？如果 `nums` 中不存在 `target` 这个值，怎么办**？

​	其实很简单，**在返回的时候额外判断一下 `nums[left]` 是否等于 `target` 就行了，如果不等于，就说明 `target` 不存在。**

​	不过我们得考察一下 `left` 的取值范围，免得索引越界。假如输入的 `target` 非常大，那么就会一直触发 `nums[mid] < target` 的 if 条件，`left` 会一直向右侧移动，直到等于 `right`，while 循环结束。

​	**由于这里 `right` 初始化为 `nums.length`，所以 `left` 变量的取值区间是闭区间 `[0, nums.length]`，那么我们在检查 `nums[left]` 之前需要额外判断一下，防止索引越界：**

**3、为什么 `left = mid + 1`，`right = mid` ？和之前的算法不一样**？

​	因为我们的「搜索区间」是 `[left, right)` 左闭右开，所以当 `nums[mid]` 被检测之后，下一步应该去 `mid` 的左侧或者右侧区间搜索，即 `[left, mid)` 或 `[mid + 1, right)`。

**4、为什么该算法能够搜索左侧边界**？

```go
if nums[mid] == target {
    // 选择mid是因为左闭右开
    right = mid
}	
```

​	可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 `right`，在区间 `[left, mid)` 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。

**5、为什么返回 `left` 而不是 `right`**？

​	都是一样的，因为 while 终止的条件是 `left == right`。

**代码**：

```go
func binSearch(nums []int, target int) int {
    left, right := 0, len(nums)
    for left < right {
        mid := left + (right-left)>>1
        if nums[mid] == target {
            // 选择mid是因为左闭右开
            right = mid  
        } else if nums[mid] < target {
            // 此时的mid不用再次使用，因此left = mid+1
            left = mid+1  
        } else if nums[mid] > target {
            // 因为搜索区间左闭右开，因此mid需要只用一次，但是right=mid
            right = mid 
        }
    }
    return left
}
```



#### 5、寻找右侧边界的二分查找

**思路**：

1）转化为搜索目标值为`target+1`的左侧边界

2）使用如下代码

```go
func binSearch(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)>>1
        if nums[mid] == target {
            // 增大搜索区间，向右边界靠拢
            left = mid+1  
        } else if nums[mid] < target {
            left = mid+1  
        } else if nums[mid] > target {
            right = mid-1
        }
    }
    return left-1  // 
}
```

**1、为什么最后返回 `left - 1` 而不像左侧边界的函数，返回 `left`？而且我觉得这里既然是搜索右侧边界，应该返回 `right` 才对**。

​	答：首先，while 循环的终止条件是 `left == right`，所以 `left` 和 `right` 是一样的，你非要体现右侧的特点，返回 `right - 1` 好了。

```go
if nums[mid] == target {
    // 可以想成mid = left-1
	left = mid+1  
}
```

**2、为什么没有返回 -1 的操作？如果 `nums` 中不存在 `target` 这个值，怎么办**？

答：只要在最后判断一下 `nums[left-1]` 是不是 `target` 就行了。类似之前的左侧边界搜索，`left` 的取值范围是 `[0, nums.length-1]`，但由于我们最后返回的是 `left - 1`，所以 `left` 取值为 0 的时候会造成索引越界，额外处理一下即可正确地返回 -1：



#### 6、二分搜索统一框架(闭区间)

##### 1 查找目标值

```go
func biSearch(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)>>1
        if nums[mid] == target {
            return mid  // 注意
        } else if nums[mid] < target {
            left = mid + 1
        } else if nums[mid] > target {
            right = mid - 1
        }
    }
    return -1
}
```

##### 2 查找左侧边界

<img src="https://labuladong.github.io/algo/images/%E4%BA%8C%E5%88%86%E8%BF%90%E7%94%A8/1.jpeg" alt="img" style="zoom:33%;" />

```go
func leftBound(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)>>1
        if nums[mid] == target {
            right = mid - 1  // 淘汰右边目标值
        } else if nums[mid] < target {
            left = mid + 1
        } else if nums[mid] > target {
            right = mid - 1
        }
    }
    // return left // 因为left没有移动，其指向的是第一个target
    if left == len(nums) {  // 防止left+1越界
        return -1
    } 
    if nums[left] == target {  // 索引left的值等于target，找到左侧边界
        return left 
    }  
    // 未找到左侧边界，返回-1
    return -1
}
```

##### 3 查找右侧边界

<img src="https://labuladong.github.io/algo/images/%E4%BA%8C%E5%88%86%E8%BF%90%E7%94%A8/2.jpeg" alt="img" style="zoom:33%;" />

```go
func rightBound(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)>>1
        if nums[mid] == target {
            left = mid + 1  // 淘汰左边目标值
        } else if nums[mid] < target {
            left = mid + 1
        } else if nums[mid] > target {
            right = mid - 1
        }
    }
    // return right // 直接返回right，也可返回mid = left - 1，
    if right < 0 {
        return -1
    }
    if nums[left] == target {
        return right
    } 
    return -1
}
```

**思想总结**

​	以上二分搜索的框架属于「术」的范畴，如果上升到「道」的层面，**二分思维的精髓就是：通过已知信息尽可能多地收缩（折半）搜索空间**，从而增加穷举效率，快速找到目标



#### 7、二分查找的实际运用

##### 1 二分搜索问题的泛化

**什么问题可以运用二分搜索算法技巧？**

​	**首先，你要从题目中抽象出一个自变量 `x`，一个关于 `x` 的函数 `f(x)`，以及一个目标值 `target`**。

同时，`x, f(x), target` 还要满足以下条件：

- `f(x)` 必须是在 `x` 上的单调函数（单调增单调减都可以）。

- 题目是让你计算满足约束条件 `f(x) == target` 时的 `x` 的值。

**例子**

​	给你一个升序排列的有序数组 `nums` 以及一个目标元素 `target`，请你计算 `target` 在数组中的索引位置，如果有多个目标元素，返回最小的索引。

​	这就是「搜索左侧边界」这个基本题型，解法代码之前都写了，但这里面 `x, f(x), target` 分别是什么呢？

​	我们可以把数组中元素的索引认为是自变量 `x`，函数关系 `f(x)` 就可以这样设定：

```go
// 函数 f(x) 是关于自变量 x 的单调递增函数
// 入参 nums 是不会改变的，所以可以忽略，不算自变量
int f(int x, int[] nums) {
    return nums[x];
}
```

​	其实这个函数 `f` 就是在访问数组 `nums`，因为题目给我们的数组 `nums` 是升序排列的，所以函数 `f(x)` 就是在 `x` 上单调递增的函数。

​	最后，题目让我们求什么来着？是不是让我们计算元素 `target` 的最左侧索引？

​	是不是就相当于在问我们「满足 `f(x) == target` 的 `x` 的最小值是多少」？

​	画个图，如下：

<img src="https://labuladong.github.io/algo/images/%E4%BA%8C%E5%88%86%E8%BF%90%E7%94%A8/3.jpeg" alt="img" style="zoom:33%;" />

**如果遇到一个算法问题，能够把它抽象成这幅图，就可以对它运用二分搜索算法**。



##### 2 运用二分搜索的套路框架

具体来说，想要用二分搜索算法解决问题，分为以下几步：

**1、确定 `x, f(x), target` 分别是什么，并写出函数 `f` 的代码**。

**2、找到 `x` 的取值范围作为二分搜索的搜索区间，初始化 `left` 和 `right` 变量**。

**3、根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码**。



##### 3 具体例子

**题目**：[875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/)

**思路**：

**1、确定 `x, f(x), target` 分别是什么，并写出函数 `f` 的代码**。

​	自变量 `x` 是什么呢？回忆之前的函数图像，二分搜索的本质就是在搜索自变量。所以，题目让求什么，就把什么设为自变量，珂珂吃香蕉的速度就是自变量 `x`。

​	f(x)：香蕉吃的越快，吃完所有香蕉堆所需的时间就越少，速度和时间就是一个单调函数关系。所以，`f(x)` 函数就可以这样定义：若吃香蕉的速度为 `x` 根/小时，则需要 `f(x)` 小时吃完所有香蕉。

​	`target` 就很明显了，吃香蕉的时间限制 `H` 自然就是 `target`，是对 `f(x)` 返回值的最大约束。

**2、找到 `x` 的取值范围作为二分搜索的搜索区间，初始化 `left` 和 `right` 变量**。

​	显然，最小速度应该是 1，最大速度是 `piles` 数组中元素的最大值，因为每小时最多吃一堆香蕉，胃口再大也白搭嘛。

**3、根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码**。

现在我们确定了自变量 `x` 是吃香蕉的速度，`f(x)` 是单调递减的函数，`target` 就是吃香蕉的时间限制 `H`，题目要我们计算最小速度，也就是 `x` 要尽可能小：

<img src="https://labuladong.github.io/algo/images/%E4%BA%8C%E5%88%86%E8%BF%90%E7%94%A8/4.jpeg" alt="img" style="zoom:33%;" />

**代码**

```go
func minEatingSpeed(piles []int, h int) int {
    left, right := 1, int(1e9+1)
    for left <= right {
        mid := left + (right-left)>>1
        q := f(piles, mid)
        if q <= h {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return left
}

func f(piles []int, x int) int {
    hours := 0
    for _, val := range piles {
        hours += val / x
        if val % x > 0 {
            hours++
        } 
    }
    return hours
}
```



**题目**：[1011. 在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)

**思路**：

**1、确定 `x, f(x), target` 分别是什么，并写出函数 `f` 的代码**。

​	题目问什么，什么就是自变量，也就是说船的运载能力就是自变量 `x`。

​	运输天数和运载能力成反比，所以可以让 `f(x)` 计算 `x` 的运载能力下需要的运输天数，那么 `f(x)` 是单调递减的。

​	对于这道题，`target` 显然就是运输天数 `D`，我们要在 `f(x) == D` 的约束下，算出船的最小载重。

**2、找到 `x` 的取值范围作为二分搜索的搜索区间，初始化 `left` 和 `right` 变量**。

船的最小载重是多少？最大载重是多少？

显然，船的最小载重应该是 `weights` 数组中元素的最大值，因为每次至少得装一件货物走，不能说装不下嘛。

最大载重显然就是`weights` 数组所有元素之和，也就是一次把所有货物都装走。

这样就确定了搜索区间 `[left, right]`

**3、需要根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码**。

​	现在我们确定了自变量 `x` 是船的载重能力，`f(x)` 是单调递减的函数，`target` 就是运输总天数限制 `D`，题目要我们计算船的最小载重，也就是 `x` 要尽可能小：

<img src="https://labuladong.github.io/algo/images/%E4%BA%8C%E5%88%86%E8%BF%90%E7%94%A8/5.jpeg" alt="img" style="zoom:33%;" />

**代码**：

```go
func shipWithinDays(weights []int, days int) int {
    left, right := 0, 1
    for _, val := range weights {
        left = max(left, val)
        right += val
    }
    for left <= right {
        mid := left + (right-left)>>1 
        if f(weights, mid) <= days {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return left
}

func f(weights []int, x int) int {
    days := 0
    for i := 0; i < len(weights); {
        cap := x 
        for i < len(weights) {
            if cap < weights[i] {
                break
            }
            cap -= weights[i]
            i++
        }
        days++
    }
    return days
}

func max(a, b int) int {
    if a < b {
        return b
    }
    return a
}
```



**题目**：[410. 分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/)

**思路：**

**1、求子数组各自和的最大值最小**

​	MM问题往往可以考虑二分法

**2、确定 `x, f(x), target` 分别是什么，并写出函数 `f` 的代码**。

​	题目问什么，什么就是自变量，也就是说子数组各自和的最大值就是自变量 `x`。

​	子数组各自和的最大值和子数组个数成反比，所以可以让 `f(x)` 计算 `x` 的子数组各自和的最大值下需要的子数组个数，那么 `f(x)` 是单调递减的。

​	对于这道题，`m` 显然就是子数组 `D`，我们要在 `f(x) == D` 的约束下，算出子数组各自和的最大值。

**3、区间确定？**

​	子数组各自和最大值的最小值是多少？最大值是多少？

​	显然`[left, right] = [原数组中的最大值，原数组的和]`

**代码**

```go
func splitArray(nums []int, k int) int {
    left, right := 0, 1
    for _, val := range nums {
        left = max(left, val)
        right += val
    }
    for left <= right {
        mid := left + (right-left)>>1
        if f(nums, mid) <= k {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return left
}

func f(nums []int, x int) int {
    res := 0 
    for i := 0; i < len(nums); {
        sum := x
        for i < len(nums) {
            if sum < nums[i] {
                break
            }
            sum -= nums[i]
            i++
        }
        res++
    }
    return res
}

func max(a, b int) int {
    if a < b {
        return b
    }
    return a
}
```



#### 总结

​	如果发现题目中存在单调关系，就可以尝试使用二分搜索的思路来解决。搞清楚单调性和二分搜索的种类，通过分析和画图，就能够写出最终的代码。





## 排序类算法

### 归并算法

#### **思想**

​	**就这么说吧，所有递归的算法，你甭管它是干什么的，本质上都是在遍历一棵（递归）树，然后在节点（前中后序位置）上执行代码，你要写递归算法，本质上就是要告诉每个节点需要做什么**。

​	**归并排序的过程可以在逻辑上抽象成一棵二叉树，树上的每个节点的值可以认为是 `nums[lo..hi]`，叶子节点的值就是数组中的单个元素**：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301071603707.jpeg" alt="img" style="zoom: 50%;" />

​	然后，在每个节点的后序位置（左右子节点已经被排好序）的时候执行 `merge` 函数，合并两个子节点上的子数组：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301071603071.jpeg" alt="img" style="zoom:50%;" />

​	这个 `merge` 操作会在二叉树的每个节点上都执行一遍，执行顺序是二叉树后序遍历的顺序。

​	结合上述基本分析，我们把 `nums[lo..hi]` 理解成二叉树的节点，`sort` 函数理解成二叉树的遍历函数，`merge`函数理解成对当前节点的操作，整个归并排序的执行过程就是以下 GIF 描述的这样：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301071602591.gif" alt="img" style="zoom:50%;" />



#### 模板

```go
var arr []int

func sortArray(nums []int) []int {
    arr = make([]int, len(nums))
    sort(nums, 0, len(nums)-1)
    return nums
}

func sort(nums []int, low, high int) {
    if low >= high {
        return 
    }
    mid := low + (high-low)>>1
    sort(nums, low, mid)
    sort(nums, mid+1, high)
    // 后序遍历位置
    merge(nums, low, mid, high)
}

func merge(nums []int, low, mid, high int) {
    // 复制nums到临时数组
    copy(arr, nums[low:high+1])

    left, right := low, mid+1
    for i := low; i <= high; i++ {
        if left == mid + 1 {
            nums[i] = arr[right-low]
            right++ 
        } else if right == high + 1 {
            nums[i] = arr[left-low]
            left++
        } else if arr[left-low] > arr[right-low] {
            nums[i] = arr[right-low]
            right++
        } else {
            nums[i] = arr[left-low]
            left++
        }
    }
}
```

- 需要使用一个辅助数组`O(n)`和一个递归栈`O(log)`，因此空间复杂度是`O(n)`

- **执行的次数是二叉树节点的个数，每次执行的复杂度就是每个节点代表的子数组的长度，所以总的时间复杂度就是整棵树中「数组元素」的个数**。

  所以从整体上看，这个二叉树的高度是 `logN`，其中每一层的元素个数就是原数组的长度 `N`，所以总的时间复杂度就是 `O(NlogN)`。



#### 例子

**题目** ：[315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)

**思路**：

拍脑袋的暴力解法就不说了，嵌套 for 循环，平方级别的复杂度。

这题和归并排序什么关系呢，主要在 `merge` 函数，**我们在使用 `merge` 函数合并两个有序数组的时候，其实是可以知道一个元素 `nums[i]` 后边有多少个元素比 `nums[i]` 小的**。

具体来说，比如这个场景：

![img](https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301072049227.jpeg)

这时候我们应该把 `temp[i]` 放到 `nums[p]` 上，因为 `temp[i] < temp[j]`。

但就在这个场景下，我们还可以知道一个信息：5 后面比 5 小的元素个数就是 左闭右开区间 `[mid + 1, j)` 中的元素个数，即 2 和 4 这两个元素：

![img](https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301072050058.jpeg)

**换句话说，在对 `nums[lo..hi]` 合并的过程中，每当执行 `nums[p] = temp[i]` 时，就可以确定 `temp[i]` 这个元素后面比它小的元素个数为 `j - mid - 1`**。

当然，`nums[lo..hi]` 本身也只是一个子数组，这个子数组之后还会被执行 `merge`，其中元素的位置还是会改变。但这是其他递归节点需要考虑的问题，我们只要在 `merge` 函数中做一些手脚，叠加每次 `merge` 时记录的结果即可。

发现了这个规律后，我们只要在 `merge` 中添加两行代码即可解决这个问题，看解法代码：

**代码**：

```go
type Pair struct {
    // 记录数组的元素值
    val int
    // 记录数组元素的原始索引
    idx int
}

// 归并排序辅助数组
var tmp []Pair
// 记录每个元素后面比自己小的元素个数
var count []int

func countSmaller(nums []int) []int {
    n := len(nums)
    tmp = make([]Pair, n)
    count = make([]int, n)
    arr := make([]Pair, n)
    // 记录元素原始的索引位置，以便在 count 数组中更新结果
    for i, val := range nums {
        arr[i] = Pair{val, i}
    }
    sort(arr, 0, n-1)

    return count
}

func sort(arr []Pair, low, high int) {
    if low >= high {
        return 
    }
    mid := low + (high-low)>>1
    sort(arr, low, mid)
    sort(arr, mid+1, high)
    // 后序遍历位置
    merge(arr, low, mid, high)
}

func merge(arr []Pair, low, mid, high int) {
    // 复制nums到临时数组
    copy(tmp, arr[low:high+1])

    left, right := low, mid+1
    for i := low; i <= high; i++ {
        if left == mid + 1 {
            arr[i] = tmp[right-low]
            right++ 
        } else if right == high + 1 {
            // 右边遍历完还没到mid，说明右边所有的元素都比mid小
            arr[i] = tmp[left-low]
            left++
            count[arr[i].idx] += right - mid - 1
        } else if tmp[left-low].val > tmp[right-low].val {
            arr[i] = tmp[right-low]
            right++
        } else {
            arr[i] = tmp[left-low]
            left++
            // 更新count数组
            count[arr[i].idx] += right - mid - 1
        }
    }
}
```



**题目**：[493. 翻转对](https://leetcode.cn/problems/reverse-pairs/)

**思路**：

​	所以解题的思路当然还是要在 `merge` 函数中做点手脚，当 `nums[lo..mid]` 和 `nums[mid+1..hi]` 两个子数组完成排序后，对于 `nums[lo..mid]` 中的每个元素 `nums[i]`，去 `nums[mid+1..hi]` 中寻找符合条件的 `nums[j]` 就行了。

- 因为右区间的元素索引一定大于左边的元素索引，因此只要使用滑动窗口的思想去遍历左子区间即可

**代码**：

```go
// 辅助数组
var tmp []int

// 答案
var res int

func reversePairs(nums []int) int {
	n := len(nums)
	tmp = make([]int, n)
    res := 0
	sort(nums, 0, n-1)

	return res
}

func sort(nums []int, low, high int) {
	if low >= high {
		return
	}
	mid := low + (high-low)>>1
	sort(nums, low, mid)
	sort(nums, mid+1, high)
	// 后序遍历位置
	merge(nums, low, mid, high)
}

func merge(nums []int, low, mid, high int) {
	// 复制nums到临时数组
	copy(tmp, nums[low:high+1])

	// 进行效率优化，维护左闭右开区间 [mid+1, end) 中的元素乘 2 小于 nums[i]
	// 为什么 end 是开区间？因为这样的话可以保证初始区间 [mid+1, mid+1) 是一个空区间
	end := mid + 1
	for i := low; i <= mid; i++ {
		for end <= high && (nums[i]-nums[end]-nums[end]) > 0 {
			end++
		}
		res += end - (mid + 1)
	}

	left, right := low, mid+1
	for i := low; i <= high; i++ {
		if left == mid+1 {
			nums[i] = tmp[right-low]
			right++
		} else if right == high+1 {
			nums[i] = tmp[left-low]
			left++
		} else if tmp[left-low] > tmp[right-low] {
			nums[i] = tmp[right-low]
			right++
		} else {
			nums[i] = tmp[left-low]
			left++
		}
	}
}
```



**题目**：[区间和的个数 - 区间和的个数](https://leetcode.cn/problems/count-of-range-sum/solution/qu-jian-he-de-ge-shu-by-leetcode-solution/)

**思路**

第一反应滑动窗口，但是当出现不满足的情况时，要如何滑动窗口，即移动指针

如果使用两个for循环，那就是暴力求解，此时会出现一个问题：重复计算前n到m项的和，用空间换时间，想到**前缀和数组**。

```go
func countRangeSum(nums []int, lower int, upper int) int {
    n := len(nums)
    // 生成前缀和数组，设置哨兵
    prefix := make([]int, n+1)
    for i, val := range nums {
        prefix[i+1] = prefix[i] + val
    }
    
    var res int
    for i, v1 := range prefix {
        for j := i+1; j <= n; j++ {
            if q := prefix[j] - v1; lower <= q && q <= upper {
                res++
            }
        }
    }

    return res
}
```

然后就。。。

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301071946145.png" alt="image-20230107194558576" style="zoom: 67%;" />

接着想到了使用归并算法+前缀和分别计算两个子区间的值，并判断左右区间之和是否在和区间内。

但是这样会遇到一个新问题，就是左右两个区间的中间区间没有进行判断，因此，引进了滑动窗口的思想，遍历左区间，在右区间寻找满足条件的窗口。

**代码**：

```go
var tmp []int

var count, low, up int

func countRangeSum(nums []int, lower int, upper int) int {
    n := len(nums)
    // 生成前缀和数组，设置哨兵
    prefix := make([]int, n+1)
    for i, val := range nums {
        prefix[i+1] = prefix[i] + val
    }

    tmp = make([]int, n+1)
    count = 0
    low, up = lower, upper
    sort(prefix, 0, n)

    return count
}

func sort(nums []int, lo, hi int) {
    if lo >= hi {
        return
    }
    mid := lo + (hi-lo)>>1
    sort(nums, lo, mid)
    sort(nums, mid+1, hi)
    merge(nums, lo, mid, hi)
}

func merge(nums []int, lo, mid, hi int) {
    copy(tmp, nums[lo:hi+1])

    // 进行效率优化
    // 维护左闭右开区间 [start, end) 中的元素和 nums[i] 的差在 [lower, upper] 中
    start, end := mid+1, mid+1
    for i := lo; i <= mid; i++ {
        // 如果 nums[i] 对应的区间是 [start, end)，
        // 那么 nums[i+1] 对应的区间一定会整体右移，类似滑动窗口
        // 因为nums[i]代表左边数组存在从0到i的前缀和等于nums[i]
        // 而nums[start]代表右边数组中存在从0到start的前缀和等于nums[start]
        for start <= hi && nums[start] - nums[i] < low {
            start++
        }
        for end <= hi && nums[end] - nums[i] <= up {
            end++
        }
        // 找到的区间
        count += end - start
    }

    left, right := lo, mid+1
	for i := lo; i <= hi; i++ {
		if left == mid+1 {
			nums[i] = tmp[right-lo]
			right++
		} else if right == hi+1 {
			nums[i] = tmp[left-lo]
			left++
		} else if tmp[left-lo] > tmp[right-lo] {
			nums[i] = tmp[right-lo]
			right++
		} else {
			nums[i] = tmp[left-lo]
			left++
		}
	}
}
```

