# 二叉树

## 纲领篇

### 1 二叉树解题的两类思维模式

- **是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。
- **是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式

### 2 思考方式

​	**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。



### 3 二叉树的重要性

​	举个例子，比如两个经典排序算法 [快速排序](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/kuai-su-pa-39aa2/) 和 [归并排序](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/gui-bing-p-1387f/)，对于它俩，你有什么理解？

​	**如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历，那么我就知道你是个算法高手了**。

​	为什么快速排序和归并排序能和二叉树扯上关系？我们来简单分析一下他们的算法思想和代码框架：

​	快速排序的逻辑是，若要对 `nums[lo..hi]` 进行排序，我们先找一个分界点 `p`，通过交换元素使得 `nums[lo..p-1]` 都小于等于 `nums[p]`，且 `nums[p+1..hi]` 都大于 `nums[p]`，然后递归地去 `nums[lo..p-1]` 和 `nums[p+1..hi]` 中寻找新的分界点，最后整个数组就被排序了。

​	快速排序的代码框架如下：

```go
func sort(nums []int, low, high int) {
    /****** 前序遍历位置 ******/
    // 通过交换元素构建分界点 p
    p := partition(nums, low, high)
    
    sort(nums, low, p-1)
    sort(nums, p+1, high)
}
```

​	先构造分界点，然后去左右子数组构造分界点，你看这不就是一个二叉树的前序遍历吗？

​	再说说归并排序的逻辑，若要对 `nums[lo..hi]` 进行排序，我们先对 `nums[lo..mid]` 排序，再对 `nums[mid+1..hi]` 排序，最后把这两个有序的子数组合并，整个数组就排好序了。

​	归并排序的代码框架如下：

```go
// 定义：排序 nums[lo..hi]
func sort(nums []int, low, high int) {
    mid := (low + high) / 2;
    // 排序 nums[low..mid]
    sort(nums, low, mid);
    // 排序 nums[mid+1..high]
    sort(nums, mid + 1, high);

    /****** 后序位置 ******/
    // 合并 nums[low..mid] 和 nums[mid+1..high]
    merge(nums, low, mid, high);
    /*********************/
}
```



### 4 深入理解前中后序

**我先甩给你几个问题，请默默思考 30 秒：**

1、你理解的二叉树的前中后序遍历是什么，仅仅是三个顺序不同的 List 吗？

2、请分析，后序遍历有什么特殊之处？

3、请分析，为什么多叉树没有中序遍历？



**二叉树遍历框架**

```go
func traverse(root *TreeNode) {
    if root == nil {
        return
    }
    // 前序位置
    traverse(root.Left)
    // 中序位置
    traverse(root.Right)
    // 后序位置
}
```

​	先不管所谓前中后序，单看 `traverse` 函数，你说它在做什么事情？

​	其实它就是一个**能够遍历二叉树所有节点的一个函数**，和你遍历数组或者链表本质上没有区别：

```go
/* 迭代遍历数组 */
func traverse(arr []int) {
    for (int i = 0; i < len(arr); i++) {

    }
}

/* 递归遍历数组 */
func traverse(arr []int, i int) {
    if (i == len(arr)) {
        return;
    }
    // 前序位置
    traverse(arr, i + 1);
    // 后序位置
}

/* 迭代遍历单链表 */
func traverse(head ListNode) {
    for (p := head; p != null; p = p.next) {

    }
}

/* 递归遍历单链表 */
func traverse(head ListNode) {
    if (head == null) {
        return;
    }
    // 前序位置
    traverse(head.next);
    // 后序位置
}
```

​	你也注意到了，只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。

**所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候**，那么进一步，你把代码写在不同位置，代码执行的时机也不同：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301041606671.jpeg" alt="img" style="zoom: 50%;" />

**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：

- 前序位置的代码在刚刚进入一个二叉树节点的时候执行；

- 后序位置的代码在将要离开一个二叉树节点的时候执行；

- 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301041608885.jpeg" alt="img" style="zoom: 33%;" />

​	**你可以发现每个节点都有「唯一」属于自己的前中后序位置**，所以我说前中后序遍历是遍历二叉树过程中处理每一个节点的三个特殊时间点。

​	这里你也可以理解为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。

​	说了这么多基础的，就是要帮你对二叉树建立正确的认识，然后你会发现：

​	**二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作**。



### 5 两种解题思路

​	**二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 [回溯算法核心框架](https://labuladong.github.io/algo/di-san-zha-24031/bao-li-sou-96f79/hui-su-sua-c26da/) 和 [动态规划核心框架](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dong-tai-g-1e688/)**。



**题目**：[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/submissions/)

**思路1**：**遍历二叉树计算答案的思路**

​	这个解法应该很好理解，但为什么需要在前序位置增加 `depth`，在后序位置减小 `depth`？

​	因为前面说了，前序位置是进入一个节点的时候，后序位置是离开一个节点的时候，`depth` 记录当前递归到的节点深度，你把 `traverse` 理解成在二叉树上游走的一个指针，所以当然要这样维护。

​	至于对 `res` 的更新，你放到前中后序位置都可以，只要保证在进入节点之后，离开节点之前（即 `depth` 自增之后，自减之前）就行了。

**代码**：

```go
func maxDepth(root *TreeNode) int {
    res := 0  // 记录最大深度
    depth := 0  // 记录当前深度

    // 二叉树遍历框架
    var traverse func(r *TreeNode)
    traverse = func(r *TreeNode) {
        if r == nil {
            return 
        }
        // 前序位置
        depth++
        // 到达叶子节点，更新最大深度
        if r.Left == nil && r.Right == nil {
            res = max(res, depth)
        }
        traverse(r.Left)
        traverse(r.Right)
        // 后序位置
        depth--
    } 

    // 递归入口
    traverse(root)
    return res
}
```

**思路2**：**分解问题计算答案的思路**

​	只要明确递归函数的定义，这个解法也不难理解，但为什么主要的代码逻辑集中在后序位置？

​	因为这个思路正确的核心在于，你确实可以通过子树的最大深度推导出原树的深度，所以当然要首先利用递归函数的定义算出左右子树的最大深度，然后推出原树的最大深度，主要逻辑自然放在后序位置。

**代码**

```go
// 定义：输入根节点，返回这棵二叉树的最大深度
func maxDepth(root *TreeNode) int {
    // 二叉树遍历框架
    var traverse func(r *TreeNode) int
    traverse = func(r *TreeNode) int {
        if r == nil {
            return 0
        }
        // 利用定义，计算左右子树的最大深度
        left := traverse(r.Left)
        right := traverse(r.Right)
        // 后序位置
        // 整棵树的最大深度等于左右子树的最大深度取最大值，
    	// 然后再加上根节点自己
        return max(left, right) + 1
    } 

    // 递归入口
    return traverse(root)
}

```



**综上，遇到一道二叉树的题目时的通用思考过程是：**

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。

**3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做**。



### 6 后序位置的特殊之处

​	说后序位置之前，先简单说下中序和前序。

​	中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。

​	前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。

​	你可以发现，前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301041650848.jpeg" alt="img" style="zoom: 33%;" />

这不奇怪，因为本文开头就说了前序位置是刚刚进入节点的时刻，后序位置是即将离开节点的时刻。

**但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。

举具体的例子，现在给你一棵二叉树，我问你两个简单的问题：

1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？

​	使用前序，将从父节点传来的信息加1

```go
// 二叉树遍历函数
func traverse(r *TreeNode, level int) {
    if r == nil {
        return 
    }
    fmt.Printf("节点%s在第%d层", r.Val, level)
    traverse(r.Left, level+1)
    traverse(r.Right, level+1)
}
```

2、如何打印出每个节点的左右子树各有多少节点？

​	使用后序，获取子树的节点个数，然后打印

```go
// 定义：输入一棵二叉树，返回这棵二叉树的节点总数
func count(r *TreeNode) int {
    if r == nil {
        return 0
    }
    left := count(r.Left)
    right := count(r.Right)
    fmt.Printf("节点%s的左子树节点: %d，右子树节点: %d", r.Val, left, right)
    return left + right + 1
}
```

​	这两个问题的根本区别在于：一个节点在第几层，你从根节点遍历过来的过程就能顺带记录；而以一个节点为根的整棵子树有多少个节点，你需要遍历完子树之后才能数清楚。

​	结合这两个简单的问题，你品味一下后序位置的特点，只有后序位置才能通过返回值获取子树的信息。

​	**那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**。

 

### 7 层序遍历





## 思路篇



**二叉树解题的思维模式分两类：**

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。



### 一、翻转二叉树

**题目**：[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/submissions/)

**思路1**：**遍历思维**

- 可以，我写一个 `traverse` 函数遍历每个节点，让每个节点的左右子节点颠倒过来就行了。
- **单独抽出一个节点**，需要让它做什么？让它把自己的左右子节点交换一下。
- 需要在什么时候做？好像前中后序位置都可以。

**代码**

```go
func invertTree(root *TreeNode) *TreeNode {
    var traverse func(r *TreeNode) 
    traverse = func(r *TreeNode) {
        if r == nil {
            return 
        }
        // 交换左右子树
        r.Left, r.Right = r.Right, r.Left
        // 遍历所有节点
        traverse(r.Left)
        traverse(r.Right)
    }

    traverse(root)
    return root
}
```

**思路2**：**「分解问题」**

​	我们尝试给 `invertTree` 函数赋予一个定义：

```go
// 定义：将以 root 为根的这棵二叉树翻转，返回翻转后的二叉树的根节点
func invertTree(root TreeNode) *TreeNode  
```

​	然后思考，对于某一个二叉树节点 `x` 执行 `invertTree(x)`，你能利用这个递归函数的定义做点啥？

​	我可以用 `invertTree(x.left)` 先把 `x` 的左子树翻转，再用 `invertTree(x.right)` 把 `x` 的右子树翻转，最后把 `x` 的左右子树交换，这恰好完成了以 `x` 为根的整棵二叉树的翻转，即完成了 `invertTree(x)` 的定义。

**代码**

```go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }

    left := invertTree(root.Left)
    right := invertTree(root.Right)

    root.Left = right
    root.Right = left

    return root 
}
```

​	**这种「分解问题」的思路，核心在于你要给递归函数一个合适的定义，然后用函数的定义来解释你的代码；如果你的逻辑成功自恰，那么说明你这个算法是正确的。**



### 二、填充节点的右侧指针

**题目**：[116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

**思路1**：**遍历思维**

- 编写一个`traverse`函数遍历所有节点
- 单独抽出一个节点，将该节点左子树每层的最右节点的`Next`指针指向右子树每层的最左节点（以根节点1为例子）

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301051224003.png" alt="image-20230105122405186" style="zoom:50%;" />

**代码**

```go
func connect(root *Node) *Node {
	var traverse func(r *Node)
	traverse = func(r *Node) {
		if r == nil {
			return
		}
		// 连接以r为根节点的所有左子树右节点和右子树左节点
		rLeft := r.Left
		rRight := r.Right
		for rLeft != nil {
			rLeft.Next = rRight
			rLeft = rLeft.Right
			rRight = rRight.Left
		}
		// 遍历
		traverse(r.Left)
		traverse(r.Right)
	}

	traverse(root)
	return root
}
```

**思路2**：**遍历思维**

​	**传统的 `traverse` 函数是遍历二叉树的所有节点，但现在我们还想遍历的其实是两个相邻节点之间的「空隙」**。

​	所以我们可以在二叉树的基础上进行抽象，你把图中的每一个方框看做一个节点：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301051233320.png" alt="img" style="zoom:33%;" />

​	**这样，一棵二叉树被抽象成了一棵三叉树，三叉树上的每个节点就是原先二叉树的两个相邻节点**。

​	现在，我们只要实现一个 `traverse` 函数来遍历这棵三叉树，每个「三叉树节点」需要做的事就是把自己内部的两个二叉树节点穿起来：

```go
func connect(root *Node) *Node {
	if root == nil {
		return nil
	}
	var traverse func(r1, r2 *Node)
	traverse = func(r1, r2 *Node) {
		if r1 == nil || r2 == nil {
			return
		}
     	// 前序位置
		// 连接两个节点
		r1.Next = r2
		// 遍历三叉树的所有节点
		traverse(r1.Left, r1.Right)
		traverse(r2.Left, r2.Right)
		traverse(r1.Right, r2.Left)
	}

	traverse(root.Left, root.Right)
	return root
}
```

​	这样，`traverse` 函数遍历整棵「三叉树」，将所有相邻节的二叉树节点都连接起来，也就避免了我们之前出现的问题，把这道题完美解决。

### 三、将二叉树展开为链表

**题目**：[114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

**思路1**：**遍历**

​	乍一看感觉是可以的：对整棵树进行前序遍历，一边遍历一边构造出一条「链表」就行了

```java
// 虚拟头节点，dummy.right 就是结果
TreeNode dummy = new TreeNode(-1);
// 用来构建链表的指针
TreeNode p = dummy;

void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // 前序位置
    p.right = new TreeNode(root.val);
    p = p.right;

    traverse(root.left);
    traverse(root.right);
}
```

​	但是注意 `flatten` 函数的签名，返回类型为 `void`，也就是说题目希望我们在原地把二叉树拉平成链表。

​	这样一来，没办法通过简单的二叉树遍历来解决这道题了。

**思路2**：**分解思维**

- 我们尝试给出 `flatten` 函数的定义：

```go
// 输入节点root，然后以root为根节点的树会被拉伸成一条链表（只有右子树）
func flatten(root *TreeNode) 
```

**代码**

```go
// 定义：将以root为根的树拉平为链表
func flatten(root *TreeNode) {
	if root == nil {
		return
	}
	// 拉平左子树
	flatten(root.Left)
	// 拉平右子树
	flatten(root.Right)

	// 后序遍历
	// 对当前节点进行操作

	// 1、此时左右子树都被拉平成链表
	left, right := root.Left, root.Right
	// 2、将左子树作为右子树
	root.Left = nil
	root.Right = left
	// 3、将原先的右子树接到当前右子树的末端
	p := root
	for p.Right != nil {
		p = p.Right
	}
	p.Right = right
}

```





## 构造篇

​	**二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树**。

### 一、最大二叉树

**题目**：[654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

**思路**：**分解思维**

```go
func constructMaximumBinaryTree(nums []int) *TreeNode {
	if len(nums) == 0 {
		return nil
	}
	max := 0
    for i, num := range nums {
        if nums[max] < num {
            max = i
        }
    }
	r := &TreeNode{Val: nums[max]}
	r.Left = constructMaximumBinaryTree(nums[:max])
	r.Right = constructMaximumBinaryTree(nums[max+1:])

	return r
}
```



### 二、从前序与中序遍历序列构造二叉树

**题目**：[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

**思路**：**分解思维**

- 函数签名

```go
// 根据先序数组和中序数组生成二叉树
func buildTree(preorder []int, inorder []int) *TreeNode
```

**代码**

```go
    func buildTree(preorder []int, inorder []int) *TreeNode {
        if len(preorder) == 0 || len(inorder) == 0 {
            return nil
        }
        // 将先序节点第一个元素出栈
        val := preorder[0]
        preorder = preorder[1:]
        // 在中序中找到该节点的索引
        index := -1
        for i, num := range inorder {
            if num == val {
                index = i
                break
            }
        }
        // 递归构建子树
        return &TreeNode{val, buildTree(preorder[:index], inorder[:index]), 
            buildTree(preorder[index:], inorder[index+1:])}
    }
```



### 三、通过后序和中序遍历结果构造二叉树

**题目**：[106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

**思路**：分解思维

- 使用`map`来优化查找过程

**代码**

````go 
func buildTree(inorder []int, postorder []int) *TreeNode {
	// 建立中序数组的索引
	hash := make(map[int]int)
	for i, val := range inorder {
		hash[val] = i
	}

	// 建树函数
	var build func(inLeft, inRight, postLeft, postRight int) *TreeNode
	build = func(inLeft, inRight, postLeft, postRight int) *TreeNode {
		if inLeft > inRight || postLeft > postRight {
			return nil
		}
		// 查找索引
		val := postorder[postRight]
		index := hash[val]
		rightSize := inRight - index
		// 递归建立子树
		return &TreeNode{val, build(inLeft, index-1, postLeft, postRight-rightSize-1),
			build(index+1, inRight, postRight-rightSize, postRight-1)}
	}

	return build(0, len(inorder)-1, 0, len(postorder)-1)
}
````



### 四、通过后序和前序遍历结果构造二叉树

**题目**：[889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

**思路**：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301051652631.jpeg" alt="img" style="zoom:50%;" />

```go
// 找到后序的位置index
// 从index将后序数组分为[postLeft, index], [index, postRight-1]
// 计算左子树的长度size = index - postL + 1
// 因此前序数组可分为[preLeft+1, preLeft+size], [preLeft+size+1, preRight]
size := index - postL + 1
```

**代码**

```go
func constructFromPrePost(preorder []int, postorder []int) *TreeNode {
    hash := make(map[int]int)
    for i, val := range postorder {
        hash[val] = i
    }

    // 建树函数
    var build func(preL, preR, postL, postR int) *TreeNode
    build = func(preL, preR, postL, postR int) *TreeNode {
        if preL > preR {
            return nil
        }
        if preL == preR {
            return &TreeNode{Val: preorder[preL]}
        }
        val := preorder[preL]
        // val的左孩子
        leftVal := preorder[preL+1]
        // 在后序中查找对应值的索引
        index := hash[leftVal]
        // 左子树的元素个数
        size := index - postL + 1
        // 子树
        root := &TreeNode{Val: val}
        root.Left = build(preL+1, preL+size, postL, index)
        root.Right = build(preL+size+1, preR, index+1, postR-1)
        return root
    }

    return build(0, len(preorder)-1, 0, len(postorder)-1)
}
```



## 序列化篇

### 前序遍历解法

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301061842221.jpeg" alt="img" style="zoom:50%;" />

```go
func (this *Codec) serialize(root *TreeNode) string {
    str := &strings.Builder{}
    var dfs func(*TreeNode)
    dfs = func(r *TreeNode) {
        if r == nil {
            str.WriteString("null,")
            return
        }
        str.WriteString(strconv.Itoa(r.Val))
        str.WriteString(",")
        dfs(r.Left)
        dfs(r.Right)
    }
    dfs(root)

    return str.String()
}

// Deserializes your encoded data to tree.
func (Codec) deserialize(data string) *TreeNode {
    sp := strings.Split(data, ",")
    var build func() *TreeNode
    build = func() *TreeNode {
        if sp[0] == "null" {
            sp = sp[1:]
            return nil
        }
        val, _ := strconv.Atoi(sp[0])
        sp = sp[1:]
        return &TreeNode{val, build(), build()}
    }
    return build()
}
```



### 中序遍历解法

​	先说结论，中序遍历的方式行不通，因为无法实现反序列化方法 `deserialize`。

### 后序遍历解法

​	注意`split`方法，遇到末尾`,`时，其会分多一个[]string出来。

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301061842221.jpeg" style="zoom:50%;" />

```go
func (this *Codec) serialize(root *TreeNode) string {
	var str bytes.Buffer
	var postOrder func(r *TreeNode)
	postOrder = func(r *TreeNode) {
		if r == nil {
			str.WriteString("null,")
			return
		}
		postOrder(r.Left)
		postOrder(r.Right)
		str.WriteString(strconv.Itoa(r.Val))
		str.WriteString(",")
	}
	postOrder(root)
	return str.String()
}

// Deserializes your encoded data to tree.
func (this *Codec) deserialize(data string) *TreeNode {
	sp := strings.Split(data, ",")
	// 去掉末尾多的空[]string
	sp = sp[:len(sp)-1]
	var build func() *TreeNode
	build = func() *TreeNode {
		n := len(sp)
		q := sp[n-1]
		sp = sp[:n-1]
		if q == "null" {
			return nil
		}
		val, _ := strconv.Atoi(q)
		// 因为后序遍历是左右根
		// 因此从后往前要根右左
		right := build()
		left := build()
		return &TreeNode{val, left, right}
	}
	return build()
}
```



### 层序遍历解法

​	需要使用辅助队列来记录父节点

<img src="https://labuladong.github.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96/3.jpeg" alt="img" style="zoom:50%;" />

```go
func (this *Codec) serialize(root *TreeNode) string {
	if root == nil {
		return ""
	}
	var str bytes.Buffer
	// 层序遍历
	queue := []*TreeNode{root}
	for len(queue) > 0 {
		q := queue[0]
		queue = queue[1:]
		if q == nil {
			str.WriteString("null,")
			continue
		}
		str.WriteString(strconv.Itoa(q.Val))
		str.WriteString(",")

		queue = append(queue, q.Left)
		queue = append(queue, q.Right)
	}

	return str.String()
}

// Deserializes your encoded data to tree.
func (this *Codec) deserialize(data string) *TreeNode {
	if data == "" {
		return nil
	}
	sp := strings.Split(data, ",")
	// 去除末尾的空string
	sp = sp[:len(sp)-1]
	q, _ := strconv.Atoi(sp[0])
	root := &TreeNode{Val: q}
	// 辅助队列
	queue := []*TreeNode{root}
	for i := 1; i < len(sp); {
		// 父节点出栈
		r := queue[0]
		queue = queue[1:]
		left, right := sp[i], sp[i+1]
		i += 2
		if left != "null" {
			valLeft, _ := strconv.Atoi(left)
			r.Left = &TreeNode{Val: valLeft}
			queue = append(queue, r.Left)
		} else {
			r.Left = nil
		}
		if right != "null" {
			valRight, _ := strconv.Atoi(right)
			r.Right = &TreeNode{Val: valRight}
			queue = append(queue, r.Right)
		} else {
			r.Right = nil
		}
	}

	return root
}
```



## 后序篇

**题目**：[652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/)

**思路**

如果你想知道以自己为根的子树是不是重复的，是否应该被加入结果列表中，你需要知道什么信息？

**你需要知道以下两点**：

**1、以我为根的这棵二叉树（子树）长啥样**？

**2、以其他节点为根的子树都长啥样**？

**首先来思考，我如何才能知道以自己为根的这棵二叉树长啥样**？

其实想到这里，就可以判断本题需要在二叉树的后序位置写代码了。

为什么？很简单呀，我要知道以自己为根的子树长啥样，是不是得先知道我的左右子树长啥样，再加上自己，就构成了整棵子树的样子？左右子树的样子，可不就得在后序位置通过递归函数的返回值传递回来吗？

现在，明确了要用后序遍历，那应该怎么描述一棵二叉树的模样呢？我们前文 [序列化和反序列化二叉树](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_62987967e4b0812e17a1c2f7/1) 其实写过了，二叉树的前序/中序/后序/层序遍历结果可以描述二叉树的结构。

那么，我就以后序遍历结果作为序列化结果吧，可以通过拼接字符串的方式把二叉树序列化。

**现在我们解决第二个问题，我知道了自己长啥样，怎么知道别人长啥样**？这样我才能知道有没有其他子树跟我重复对吧。

这很简单呀，我们借助一个外部数据结构，让每个节点把自己子树的序列化结果存进去，这样，对于每个节点，不就可以知道有没有其他节点的子树和自己重复了么？

初步思路可以使用 `HashSet` 记录所有子树的序列化结果，代码如下：

**代码1：使用字符串来唯一标识一颗树**

```go
type node struct {
    num int
    arr *TreeNode
}

func findDuplicateSubtrees(root *TreeNode) []*TreeNode {
    // 记录所有节点对应的后序序列字符串
    strMap := map[string]*node{}
    // 后序 序列化以r为节点的子树
    var serialize func(r *TreeNode) string 
    serialize = func(r *TreeNode) string {
        if r == nil {
            return "#"
        }
        var str bytes.Buffer
        str.WriteString(serialize(r.Left))
        str.WriteString(",")
        str.WriteString(serialize(r.Right))
        // 后序位置
        str.WriteString(",")
        str.WriteString(strconv.Itoa(r.Val))
        q := str.String()
        if _, ok := strMap[q]; !ok {
            // 第一次出现
            strMap[q] = &node{1, r}
        } else {
            strMap[q].num++
        }
        
        return q
    }
    
    _ = serialize(root)
    // 记录答案
    res := []*TreeNode{}
    for _, val := range strMap {
        if val.num >= 2 {
            res = append(res, val.arr)
        }
    }

    return res
}

```

**代码2：用一个三元组直接表示一棵子树**

通过方法一中的递归序列化技巧，我们可以进一步进行优化。

我们可以用一个三元组直接表示一棵子树，即 (x, l, r)(x,l,r)，它们分别表示：

- 根节点的值为 x；

- 左子树的序号为 l；

- 右子树的序号为 r。


这里的「序号」指的是：每当我们发现一棵新的子树，就给这棵子树一个序号，用来表示其结构。那么两棵树是重复的，当且仅当它们对应的三元组完全相同。

使用「序号」的好处在于同时减少了时间复杂度和空间复杂度。方法一的瓶颈在于生成的序列会变得非常长，而使用序号替换整个左子树和右子树的序列，可以使得每一个节点只使用常数大小的空间。

```go
func findDuplicateSubtrees(root *TreeNode) []*TreeNode {
    type pair struct {
        node *TreeNode  // 对应的根节点
        idx  int        // 新的子树序号
    }
    // 记录该子树是否已在答案中
    set := map[*TreeNode]struct{}{}
    // 记录该子树序列是否出现过
    seen := map[[3]int]pair{}
    // 输入根节点，返回该节点的序列值
    idx := 0
    var dfs func(r *TreeNode) int 
    dfs = func(r *TreeNode) int {
        if r == nil {
            return 0
        }
        tri := [3]int{r.Val, dfs(r.Left), dfs(r.Right)}
        // 判断该子树结构是否已存在
        if p, ok := seen[tri]; ok {
            set[p.node] = struct{}{}
            // 返回该子树结构的序列值
            return p.idx
        }
        idx++
        seen[tri] = pair{r, idx}

        return idx
    }

    dfs(root)
    res := make([]*TreeNode, 0, len(set))
    for node := range set {
        res = append(res, node)
    }

    return res
}
```

#### 总结

​	**前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。**

​	那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。



# 归并排序的实质 —— 二叉树的后序遍历

​	详细看[排序算法中的归并算法](./查找排序算法.md/###归并排序)

### **归并算法的思想**：

​	**就这么说吧，所有递归的算法，你甭管它是干什么的，本质上都是在遍历一棵（递归）树，然后在节点（前中后序位置）上执行代码，你要写递归算法，本质上就是要告诉每个节点需要做什么**。

​	**归并排序的过程可以在逻辑上抽象成一棵二叉树，树上的每个节点的值可以认为是 `nums[lo..hi]`，叶子节点的值就是数组中的单个元素**：

<img src="https://labuladong.github.io/algo/images/%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f/1.jpeg" alt="img" style="zoom: 50%;" />

​	然后，在每个节点的后序位置（左右子节点已经被排好序）的时候执行 `merge` 函数，合并两个子节点上的子数组：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301071601384.jpeg" alt="img" style="zoom:50%;" />

​	这个 `merge` 操作会在二叉树的每个节点上都执行一遍，执行顺序是二叉树后序遍历的顺序。

​	结合上述基本分析，我们把 `nums[lo..hi]` 理解成二叉树的节点，`sort` 函数理解成二叉树的遍历函数，`merge`函数理解成对当前节点的操作，整个归并排序的执行过程就是以下 GIF 描述的这样：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301071602591.gif" alt="img" style="zoom:50%;" />





# 二叉搜索树（Binary Search Tree）



## 特性篇



### BST的定义

1、对于 BST 的每一个节点 `node`，左子树节点的值都比 `node` 的值要小，右子树节点的值都比 `node` 的值大。

2、对于 BST 的每一个节点 `node`，它的左侧子树和右侧子树都是 BST。

​	二叉搜索树并不算复杂，但我觉得它可以算是数据结构领域的半壁江山，直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。

**总结**：BST的每一个节点都满足**左小右大**，每一个节点的**左右子树都是BST**。



### BST的特性

​	**BST 的中序遍历结果是有序的（升序）**。

​	也就是说，如果输入一棵 BST，以下代码可以将 BST 中每个节点的值升序打印出来：

```go
func traverse(r *TreeNode) {
    if r == nil {
        return 
    }
    traverse(r.Left)
    // 中序遍历位置
    visit(r)
    traverse(r.Right)
}
```



### 实例

**题目：**[230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

**思路**：递归中序遍历

- `BST`中序遍历是升序，因此可以使用中序遍历来查找`BST`中第`k`小的元素。
- 优化方向：当我们找到第`k`小的元素时，不用继续遍历树中剩余节点，因此可以添加一个提前退出的判断。

**代码**

```go
 // 时间复杂度：最坏情况k是最后一个节点，因此需要遍历所有节点，故为O(n)
 // 空间复杂度：无辅助变量O(1)，递归栈O(logn)，故为O(logn)
func kthSmallest(root *TreeNode, k int) int {    
    res := -1
    var traverse func(r *TreeNode) 
    traverse = func(r *TreeNode) {
        if r == nil || k == 0 {
            return 
        }
        traverse(r.Left)
        // 中序遍历位置
        k-- 
        if k == 0 {
            res = r.Val
        }
        traverse(r.Right)
    }

    traverse(root)
    return res
}
```

**代码**：实现带节点子树个数的BST

```go
// 功能：返回第k大的元素

type countBST struct {
	Val   int       // 节点值
	Left  *countBST // 左孩子
	Right *countBST // 右孩子
	size  int       // 该节点为根节点的子树的节点总数
}

type KthLargest struct {
	root *countBST
	k    int
}

func Constructor(k int, nums []int) KthLargest {
    if len(nums) == 0 {
        return KthLargest{nil, k}
    }
	// 排序nums数组，方便生成的BST相对平衡
	sort.Ints(nums)
	var build func(low, high int) *countBST
	build = func(low, high int) *countBST {
		if low > high {
			return nil
		}
		mid := low + (high-low)>>1
		left := build(low, mid-1)
		right := build(mid+1, high)
		size := 1
		if left != nil {
			size += left.size
		}
		if right != nil {
			size += right.size
		}
		return &countBST{nums[mid], left, right, size}
	}

	return KthLargest{build(0, len(nums)-1), k}
}

func (this *KthLargest) Add(val int) int {
    // 由于在查找第 k 大元素时，数组中至少有 k 个元素
    //当root为nil时，新建一个根节点，此时返回第1（k）大元素
    if this.root == nil {
		this.root = &countBST{Val: val, size: 1}
		return val
	}
	root := this.root
    var pre *countBST
	for root != nil {
		pre = root
		root.size++
		if root.Val < val {
			root = root.Right
		} else {
			root = root.Left
		}
	}
	if pre.Val >= val {
		pre.Left = &countBST{Val: val, size: 1}
	} else {
	    pre.Right = &countBST{Val: val, size: 1}
	}

	return searchK(this)
}

// 查找第k大元素
func searchK(this *KthLargest) int {
	root, k := this.root, this.k
	for {
		// root右子树的节点数
		rightSum := 0
		if root.Right != nil {
			rightSum += root.Right.size
		}
		if rightSum < k-1 {
			root = root.Left
			k = k - rightSum - 1
		} else if rightSum == k-1 {
			return root.Val
		} else {
			root = root.Right
		}
	}
}
```



**题目**：[1038. 从二叉搜索树到更大和树](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/submissions/)

**思路**

- 每个节点的值替换成树中大于或者等于该节点值的所有节点值之和 ——> 即每个节点的值 = 节点值 + 右子树节点和
- 这显然需要子树的数据，因此考虑dfs，也就是后序遍历
- 但是本题需要的子树顺序是：右子树，根节点，左子树
- 因此本题的遍历顺序应该是**镜像中序遍历**

**代码**

```go
// 输入一颗BST，返回一颗GST
func bstToGst(root *TreeNode) *TreeNode {
    sum := 0
    var traverse func(r *TreeNode) 
    traverse = func(r *TreeNode) {
        if r == nil {
            return 
        }
        traverse(r.Right)
        // 中序位置
        sum += r.Val
        r.Val = sum
        traverse(r.Left)
    }

    traverse(root)
    return root
}
```



## 基操篇

### 判断 `BST` 的合法性

**题目**：[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

**思路1**：**自顶向下的递归**

​	函数签名

```go
// 判断root.Val是否在(lower, upper)这一区间
func helper(root *TreeNode, lower, upper int) bool
```

```go
// 判断左子树是否在(lower, root.Val)区间
// 判断右子树是否在(root.Val, upper)区间
return helper(root.Left, lower, root.Val) && helper(root.Right, root.Val, upper)
```

**代码**：

```go
func isValidBST(root *TreeNode) bool {
    return helper(root, math.MinInt64, math.MaxInt64)
}

func helper(root *TreeNode, lower, upper int) bool {
    if root == nil {
        return true
    }
    if root.Val <= lower || root.Val >= upper {
        return false
    }
    return helper(root.Left, lower, root.Val) && helper(root.Right, root.Val, upper)
}
```

**思路2**：**中序遍历+递归**

​	使用辅助变量保存中序遍历前一个节点的值，然后判断当前节点和前一个结点值的大小

**代码**

```go
func isValidBST(root *TreeNode) bool {
    count := 0
    minNum := math.MinInt64

    var dfs func(r *TreeNode)
    dfs = func(r *TreeNode) {
        if r == nil || count != 0 {
            return 
        }
        dfs(r.Left)
        if r.Val <= minNum {
            count++
            return
        }
        minNum = r.Val
        dfs(r.Right)
    }

    dfs(root)
    return count == 0
}
```



### 在 `BST` 中搜索元素

**题目：**[700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/submissions/)

**思路：**

**代码1：**递归

````go
// 时间复杂度：最坏的情况是单支树，要遍历树中所有节点，为O(n)
// 空间复杂度：需要一个递归栈，为O(n)
func searchBST(root *TreeNode, val int) *TreeNode {
    if root == nil {
        return nil
    }
    if root.Val == val {
        return root
    } else if root.Val < val {
        return searchBST(root.Right, val)
    } else {
        return searchBST(root.Left, val)
    }
}
````

**代码2：**非递归

```go
// 时间复杂度：最坏的情况是单支树，要遍历树中所有节点，为O(n)
// 空间复杂度：O(1)
func searchBST(root *TreeNode, val int) *TreeNode {
    for root != nil {
        if root.Val == val {
            return root
        } else if root.Val < val {
            root = root.Right
        } else {
            root = root.Left
        }
    }

    return nil
}
```



### 在 `BST` 中插入一个数

​	对数据结构的操作无非遍历 + 访问，遍历就是「找」，访问就是「改」。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。

​	上一个问题，我们总结了 `BST` 中的遍历框架，就是「找」的问题。直接套框架，加上「改」的操作即可。**一旦涉及「改」，就类似二叉树的构造问题，函数要返回 `TreeNode` 类型，并且要对递归调用的返回值进行接收**。

**代码**

```go
func insertIntoBST(root *TreeNode, val int) *TreeNode {
    // 找到空位置插入新节点
    if root == nil {
        return &TreeNode{Val: val}
    }
    // if (root.val == val)
    // BST 中一般不会插入已存在元素
    if root.Val < val {
        root.Right = insertIntoBST(root.Right, val)
    } 
    if root.Val > val {
        root.Left = insertIntoBST(root.Left, val)
    }
    return root
}
```



### 在 `BST` 中删除一个数

**题目**：[450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

**思路**：在`BST`中删除一个数 == 在`BST`中【找】到一个数，然后对树进行【改】

```go
func deleteNode(root *TreeNode, key int) *TreeNode {
    if root.Val == key {
        // 找到啦，进行删除
    } else if root.Val > key {
        // 在左子树查找key
        root.Left = deleteNode(root.Left, key)
    } else if root.Val < key {
        // 在右子树查找key
        root.Right = deleteNode(root.Right, key)
    }

    return root
}
```



**代码：**

```go
func deleteNode(root *TreeNode, key int) *TreeNode {
    if root == nil {
        return nil
    }

    if root.Val == key {
        // 处理只有左孩子或者右孩子的情况
        if root.Left == nil {
            return root.Right
        }
        if root.Right == nil {
            return root.Left
        }

        // 处理同时有左右孩子的情况
        // 寻找右孩子的最左节点
        p := root.Right
        for p.Left != nil {
            p = p.Left
        }
        // 转换成在右子树删除p
        root.Right = deleteNode(root.Right, p.Val)
        p.Left = root.Left
        p.Right = root.Right
        root = p
    } else if root.Val > key {
        // 在左子树查找key
        root.Left = deleteNode(root.Left, key)
    } else if root.Val < key {
        // 在右子树查找key
        root.Right = deleteNode(root.Right, key)
    }

    return root
}
```



### 总结

1、如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。

2、在二叉树递归框架之上，扩展出一套 `BST` 代码框架：

```go
func BST(root *TreeNode, target int) {
    if root.Val == target {
        // 找到目标，处理问题
    } 
    if root.Val < target {
        BST(root.Right, target)
    }
    if root.Val > target {
        BST(root.Left, target)
    }
} 
```



## 构造篇

**题目：**

**思路：**

​	举个例子，比如给算法输入 `n = 5`，也就是说用 `{1,2,3,4,5}` 这些数字去构造 BST。

​	首先，这棵 BST 的根节点总共有几种情况？

​	显然有 5 种情况对吧，因为每个数字都可以作为根节点。

​	比如说我们固定 `3` 作为根节点，这个前提下能有几种不同的 BST 呢？

​	根据 BST 的特性，根节点的左子树都比根节点的值小，右子树的值都比根节点的值大。

​	所以如果固定 `3` 作为根节点，左子树节点就是 `{1,2}` 的组合，右子树就是 `{4,5}` 的组合。

​	**左子树的组合数和右子树的组合数乘积**就是 `3` 作为根节点时的 BST 个数。

<img src="https://labuladong.github.io/algo/images/BST3/1.jpeg" alt="img" style="zoom: 50%;" />

​	这样，题目的要求已经实现了，但是时间复杂度非常高，肯定存在重叠子问题。

​	前文动态规划相关的问题多次讲过消除重叠子问题的方法，无非就是加一个备忘录：

**代码：**

```go
func numTrees(n int) int {
    // 备忘录，memo[i]代表i个数字能组成的BST个数
    memo := make([][]int, n+1)
    for i := range memo {
        memo[i] = make([]int, n+1)
    }
    // 定义：闭区间 [low, high] 的数字能组成 count(low, high) 种 BST
    var count func(low, high int) int 
    count = func(low, high int) int {
        if low > high {
            return 1
        }
        if memo[low][high] != 0 {
            return memo[low][high]
        }
        res := 0
        for i := low; i <= high; i++ {
            left := count(low, i-1)
            right := count(i+1, high)
            res += left * right
        }
        memo[low][high] = res
        return res
    }

    return count(1, n)
}

func max(a, b int) int {
    if a < b {
        return b
    }
    return a
}
```



**题目：**[95. 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/)

**思路：**

​	1、穷举 `root` 节点的所有可能。

​	2、递归构造出左右子树的所有有效 BST。

​	3、给 `root` 节点穷举所有左右子树的组合。

**代码：**

```go
func generateTrees(n int) []*TreeNode {
    var count func(low, high int) []*TreeNode
    count = func(low, high int) []*TreeNode {
        res := []*TreeNode{}
        if low > high {
            res = append(res, nil)
            return res
        }

        // 穷举所有节点
        for i := low; i <= high; i++ {
            left := count(low, i-1)
            right := count(i+1, high)
            // 3、给 root 节点穷举所有左右子树的组合。
            for _, l := range left {
                for _, r := range right {
                    root := &TreeNode{i, l, r}
                    res = append(res, root)
                }
            }
        }

        return res
    }

    return count(1, n)
}
```





# 快速排序的实质 —— 二叉树的前序遍历

​	快速排序的划分框架，可以看出其类似于二叉树的前序遍历。

```go
func sort(nums []int, low, high int) {
    if low >= high {
        return 
    }
    // 对 nums[low..high] 进行切分
    // 使得 nums[low..p-1] <= nums[p] < nums[p+1..high]
    p := partioion(nums, low, high)
    // 去左右子数组进行切分
    sort(nums, low, p - 1)
    sort(nums, p + 1, high)
    
}
```

**快速排序的具体思想请看：**[快速排序](./查找排序算法.md/###快速排序)

---------------------------------





# 迭代器的思想 —— 多叉树遍历

**题目**：[341. 扁平化嵌套列表迭代器](https://leetcode.cn/problems/flatten-nested-list-iterator/)

**思路**：

首先，现在有一种数据结构 `NestedInteger`，**这个结构中存的数据可能是一个 `Integer` 整数，也可能是一个 `NestedInteger` 列表**。注意，这个列表里面装着的是 `NestedInteger`，也就是说这个列表中的每一个元素可能是个整数，可能又是个列表，这样无限递归嵌套下去……

`NestedInteger` 有如下 API：

```java
public class NestedInteger {
    // 如果其中存的是一个整数，则返回 true，否则返回 false
    public boolean isInteger();

    // 如果其中存的是一个整数，则返回这个整数，否则返回 null
    public Integer getInteger();

    // 如果其中存的是一个列表，则返回这个列表，否则返回 null
    public List<NestedInteger> getList();
}
```

我们的算法会被输入一个 `NestedInteger` 列表，我们需要做的就是写一个迭代器类，将这个带有嵌套结构 `NestedInteger` 的列表「拍平」：

```go
type NestedIterator struct {
    Iterator []int
}
// 构造器输入一个 NestedInteger 列表，并返回一个NestedIterator的指针
func Constructor(nestedList []*NestedInteger) *NestedIterator {}

// 返回下一个整数
func (this *NestedIterator) Next() int {}

// 是否还有下一个元素？
func (this *NestedIterator) HasNext() bool {}
```

回想这个算法问题，`NestedInteger` 结构实际上也是一种支持无限嵌套的结构，而且可以同时表示整数和列表两种不同类型，我想 Notion 的核心数据结构 block 估计也是这样的一种设计思路。

那么话说回来，对于这个算法问题，我们怎么解决呢？`NestedInteger` 结构可以无限嵌套，怎么把这个结构「打平」，为迭代器的调用者屏蔽底层细节，得到扁平化的输出呢？

```java
public class NestedInteger {
    private Integer val;
    private List<NestedInteger> list;

    public NestedInteger(Integer val) {
        this.val = val;
        this.list = null;
    }
    public NestedInteger(List<NestedInteger> list) {
        this.list = list;
        this.val = null;
    }

    // 如果其中存的是一个整数，则返回 true，否则返回 false
    public boolean isInteger() {
        return val != null;
    }

    // 如果其中存的是一个整数，则返回这个整数，否则返回 null
    public Integer getInteger() {
        return this.val;
    }

    // 如果其中存的是一个列表，则返回这个列表，否则返回 null
    public List<NestedInteger> getList() {
        return this.list;
    }
}
```

嗯，其实这个实现也不难嘛，写出来之后，我不禁翻出前文 [学习数据结构和算法的框架思维](https://labuladong.github.io/article/fname.html?fname=学习数据结构和算法的高效方法)，发现这玩意儿竟然……

```java
class NestedInteger {
    Integer val;
    List<NestedInteger> list;
}

/* 基本的 N 叉树节点 */
class TreeNode {
    int val;
    TreeNode[] children;
}
```

**这玩意儿不就是棵 N 叉树吗？叶子节点是 `Integer` 类型，其 `val` 字段非空；其他节点都是 `List<NestedInteger>` 类型，其 `val` 字段为空，但是 `list` 字段非空，装着孩子节点**。

比如说输入是 `[[1,1],2,[1,1]]`，其实就是如下树状结构：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301112308330.jpeg" alt="img" style="zoom: 50%;" />

好的，刚才题目说什么来着？把一个 `NestedInteger` 扁平化对吧？**这不就等价于遍历一棵 N 叉树的所有「叶子节点」吗**？我把所有叶子节点都拿出来，不就可以作为迭代器进行遍历了吗？

```java
void traverse(TreeNode root) {
    for (TreeNode child : root.children)
        traverse(child);
```

这个框架可以遍历所有节点，而我们只对整数型的 `NestedInteger` 感兴趣，也就是我们只想要「叶子节点」，所以 `traverse` 函数只要在到达叶子节点的时候把 `val` 加入结果列表即可：

```go
type NestedIterator struct {
    Iterator []int
}

func Constructor(nestedList []*NestedInteger) *NestedIterator {
    res := []int{}

    var traverse func(root *NestedInteger) 
    traverse = func(root *NestedInteger) {
        if root.IsInteger() {
            // 叶子节点
            res = append(res, root.GetInteger())
            return
        }
        // 不需要对非叶节点进行操作
        // 直接递归调用即可
        for _, child := range root.GetList() {
            traverse(child)
        }
    }

    for _, nest := range nestedList {
        traverse(nest)
    }

    return &NestedIterator{res}
}

func (this *NestedIterator) Next() int {
    q := this.Iterator[0]
    this.Iterator = this.Iterator[1:]
    return q
}

func (this *NestedIterator) HasNext() bool {
    return len(this.Iterator) > 0 
}
```

这样，我们就把原问题巧妙转化成了一个 N 叉树的遍历问题，并且得到了解法。

**进阶思路**

以上解法虽然可以通过，但是在面试中，也许是有瑕疵的。

我们的解法中，一次性算出了所有叶子节点的值，全部装到 `result` 列表，也就是内存中，`next` 和 `hasNext` 方法只是在对 `result` 列表做迭代。如果输入的规模非常大，构造函数中的计算就会很慢，而且很占用内存。

一般的迭代器求值应该是「惰性的」，也就是说，如果你要一个结果，我就算一个（或是一小部分）结果出来，而不是一次把所有结果都算出来。

如果想做到这一点，使用递归函数进行 DFS 遍历肯定是不行的，而且我们其实只关心「叶子节点」，所以传统的 BFS 算法也不行。实际的思路很简单：

**调用 `hasNext` 时，如果 `nestedList` 的第一个元素是列表类型，则不断展开这个元素，直到第一个元素是整数类型**。

由于调用 `next` 方法之前一定会调用 `hasNext` 方法，这就可以保证每次调用 `next` 方法的时候第一个元素是整数型，直接返回并删除第一个元素即可。

看一下代码：

```go
type NestedIterator struct {
    list []*NestedInteger
}

func Constructor(nestedList []*NestedInteger) *NestedIterator {
    return &NestedIterator{nestedList}
}

func (this *NestedIterator) Next() int {
    q := this.list[0]
    this.list = this.list[1:]

    return q.GetInteger()
}

func (this *NestedIterator) HasNext() bool {
    // 循环拆分列表元素，直到列表第一个元素是整数类型
    for len(this.list) > 0 && !this.list[0].IsInteger() {
        // 当列表开头第一个元素是列表类型时，进入循环
        // 将一个*NestedInteger转换成一个[]*NestedInteger
        q := this.list[0].GetList()
        // 将第一个列表打平并按顺序添加到开头
        res := make([]*NestedInteger, len(q))
        for i, li := range q {
            res[i] = li
        }
        this.list = append(res, this.list[1:]...)
    }
    return len(this.list) > 0
}
```



-------------------------------------------------



# 计算完全二叉树的节点数



**完全二叉树和满二叉树的区别**

​	**完全二叉树**如下图，每一层都是紧凑靠左排列的：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301120021731.png" alt="img" style="zoom:50%;" />

​	**满二叉树**如下图，是一种特殊的完全二叉树，每层都是是满的，像一个稳定的三角形

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301120022614.png" alt="img" style="zoom: 80%;" />

​	说句题外话，关于这两个定义，中文语境和英文语境似乎有点区别，我们说的完全二叉树对应英文 Complete Binary Tree，没有问题。但是我们说的满二叉树对应英文 Perfect Binary Tree，而英文中的 Full Binary Tree 是指一棵二叉树的所有节点要么没有孩子节点，要么有两个孩子节点。如下：

![img](https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301120022430.png)



**题目**：[222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

**思路**：

**如何求一棵完全二叉树的节点个数呢？**

```go
// 输入一棵完全二叉树，返回节点总数
func countNodes(root *TreeNode) int 
```

如果是一个**普通**二叉树，显然只要向下面这样遍历一边即可，时间复杂度 O(N)：

```go
func countNodes(root *TreeNode) int {
    if root == nil {
        return 0
    }
    return countNodes(root.Left) + countNodes(root.Right) + 1
}
```

那如果是一棵**满**二叉树，节点总数就和树的高度呈指数关系：

```go
func countNodes(root *TreeNode) int {
    high := 0
    for root != nil {
        root = root.Left
        height++
    }
    return pow2(high) - 1
}

func pow2(n int) int {
    sum := 1
    for n > 1 {
        sum *= 2
        n--
    }
    return sum
} 
```

**完全**二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版，先看代码：

```go
func countNodes(root *TreeNode) int {
    l, r := root, root
    // 沿最左侧和最右侧分别计算高度
    hl, hr := 0, 0
    for l != nil {
        l = l.Left
        hl++
    }
    for r != nil {
        r = r.Right
        hr++
    }
    // 以root为根的子树是一颗满二叉树
    if hl == hr {
        return pow2(hl) - 1
    }
    // 以root为根的子树不是一颗满二叉树，按普通树处理
    return 1 + countNodes(root.Left) + countNodes(root.Right)

}

func pow2(n int) int {
    sum := 1
    for n > 0 {
        sum *= 2
        n--
    }
    return sum
} 
```

**复杂度分析**：

### 二、复杂度分析

开头说了，这个算法的时间复杂度是 `O(logN*logN)`，这是怎么算出来的呢？

直觉感觉好像最坏情况下是 `O(N*logN)` 吧，因为之前的 while 需要 `logN` 的时间，最后要 `O(N)`的时间向左右子树递归：

​	**关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发 `hl == hr` 而立即返回，不会递归下去**。

为什么呢？原因如下：

​	**一棵完全二叉树的两棵子树，至少有一棵是满二叉树**：

<img src="https://labuladong.github.io/algo/images/complete_tree/1.jpg" alt="img" style="zoom: 50%;" />

看图就明显了吧，由于完全二叉树的性质，其子树一定有一棵是满的，所以一定会触发 `hl == hr`，只消耗 O(logN) 的复杂度而不会继续递归。

综上，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN)。

所以说，「完全二叉树」这个概念还是有它存在的原因的，不仅适用于数组实现二叉堆，而且连计算节点总数这种看起来简单的操作都有高效的算法实现。
