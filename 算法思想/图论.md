# 图论



## 图论基础

--------------------------------------------------

### 概念



#### 度（degree）

- 在==无向图==中，「度」就是每个节点相连的边的条数。

- 由于==有向图==的边有方向，所以有向图中每个节点「度」被细分为**入度**（indegree）和**出度**（outdegree），比如下图：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301122041135.jpeg" alt="img" style="zoom: 67%;" />

​	其中节点 `3` 的入度为 3（有三条边指向它），出度为 1（它有 1 条边指向别的节点）。





---------------------------------------



### 图的逻辑结构和具体实现

一幅图是由**节点**和**边**构成的，逻辑结构如下：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301122010113.jpeg" alt="img" style="zoom: 80%;" />

**什么叫「逻辑结构」？就是说为了方便研究，我们把图抽象成这个样子**。

根据这个逻辑结构，我们可以认为每个节点的实现如下：

```go
/* 图节点的逻辑结构 */
type Vertex struct {
    val 	  int
    neighbors []*Vertex
}
```

可以发现，图的逻辑结构和多叉树非常相似

```go
/* 基本的 N 叉树节点 */
type TreeNode struct {
    val 	 int
    children []*TreeNode
}
```

**所以说，图真本质上就是个高级点的多叉树而已，适用于树的 DFS/BFS 遍历算法，全部适用于图。**

上面的这种实现是「逻辑上的」，其相当于一个多叉树，然后图则由多个Vertex节点组成。

实际上我们很少用这个 `Vertex` 类实现图，而是用常说的**邻接表和邻接矩阵**来实现。



### 具体实现

比如还是刚才那幅图：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301122010113.jpeg" alt="img" style="zoom: 80%;" />

用邻接表和邻接矩阵的存储方式如下：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301122021790.jpeg" alt="img" style="zoom: 50%;" />

- 邻接表很直观，我把每个节点 `x` 的邻居都存到一个列表里，然后把 `x` 和这个列表关联起来，这样就可以通过一个节点 `x` 找到它的所有相邻节点。
- 邻接矩阵则是一个二维数组，我们权且称为 `matrix`，如果节点 `x` 和 `y` 是相连的，那么就把 `matrix[x][y]` 设为 `true`（上图中绿色的方格代表 `true`）。如果想找节点 `x` 的邻居，去扫一圈 `matrix[x][..]` 就行了。

**代码实现**

```go
// 邻接表

// 邻接矩阵
// matrix[x][y] 记录 x 是否有一条指向 y 的边
matrix [][]bool
```



### 两种存储方式的优缺点

对于邻接表，**好处是占用的空间少**。

但是，**邻接表无法快速判断两个节点是否相邻。**

比如说我想判断节点 `1` 是否和节点 `3` 相邻，我要去邻接表里 `1` 对应的邻居列表里查找 `3` 是否存在。但对于邻接矩阵就简单了，只要看看 `matrix[1][3]` 就知道了，效率高。





### 图的遍历

**各种数据结构被发明出来无非就是为了遍历和访问，所以「遍历」是所有数据结构的基础**。

图怎么遍历？还是那句话，参考多叉树，多叉树的 DFS 遍历框架如下：

```GO
/* 多叉树遍历框架 */
func traverse(root TreeNode) {
    if root == nil {
        return 
    }
    // 前序位置
    for child := range root.childern {
        traverse(child)
    }
    // 后序位置
}
```



​	**图和多叉树最大的区别是，图是可能包含环的**，你从图的某一个节点开始遍历，有可能走了一圈又回到这个节点，而树不会出现这种情况，从某个节点出发必然走到叶子节点，绝不可能回到它自身。

==所以，如果图包含环，遍历框架就要一个 `visited` 数组进行辅助==：

```go
// 记录被遍历过的节点
visited []bool
// 记录从起点到当前节点的路径
onPath  []bool

/* 图遍历框架 */
func traverse(graph Graph, s int) {
    // 由于图可能有环，因此不能像遍历树一样，设置节点nil为递归结束条件
    // 所以需要使用一个辅助数组，用来记录被遍历过的节点
    // 当节点被访问过时，递归结束
    if visited[s] {
        return 
    }
    // 经过节点 s，标记为已遍历
    visited[s] = true
    // 做选择：标记节点 s 在路径上
    onPath[s] = true
    for neighbor := range graph.neighbors(s) {
        traverse(graph, neighbor)
    }
    

}
```

