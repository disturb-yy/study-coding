# 图论



## 图论基础

--------------------------------------------------

### 概念



#### 度（degree）

- 在==无向图==中，「度」就是每个节点相连的边的条数。

- 由于==有向图==的边有方向，所以有向图中每个节点「度」被细分为**入度**（indegree）和**出度**（outdegree），比如下图：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301122041135.jpeg" alt="img" style="zoom: 67%;" />

​	其中节点 `3` 的入度为 3（有三条边指向它），出度为 1（它有 1 条边指向别的节点）。





---------------------------------------



### 图的逻辑结构和具体实现

一幅图是由**节点**和**边**构成的，逻辑结构如下：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301122010113.jpeg" alt="img" style="zoom: 80%;" />

**什么叫「逻辑结构」？就是说为了方便研究，我们把图抽象成这个样子**。

根据这个逻辑结构，我们可以认为每个节点的实现如下：

```go
/* 图节点的逻辑结构 */
type Vertex struct {
    val 	  int
    neighbors []*Vertex
}
```

可以发现，图的逻辑结构和多叉树非常相似

```go
/* 基本的 N 叉树节点 */
type TreeNode struct {
    val 	 int
    children []*TreeNode
}
```

**所以说，图真本质上就是个高级点的多叉树而已，适用于树的 DFS/BFS 遍历算法，全部适用于图。**

上面的这种实现是「逻辑上的」，其相当于一个多叉树，然后图则由多个Vertex节点组成。

实际上我们很少用这个 `Vertex` 类实现图，而是用常说的**邻接表和邻接矩阵**来实现。



### 具体实现

比如还是刚才那幅图：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301122010113.jpeg" alt="img" style="zoom: 80%;" />

用邻接表和邻接矩阵的存储方式如下：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301122021790.jpeg" alt="img" style="zoom: 50%;" />

- 邻接表很直观，我把每个节点 `x` 的邻居都存到一个列表里，然后把 `x` 和这个列表关联起来，这样就可以通过一个节点 `x` 找到它的所有相邻节点。
- 邻接矩阵则是一个二维数组，我们权且称为 `matrix`，如果节点 `x` 和 `y` 是相连的，那么就把 `matrix[x][y]` 设为 `true`（上图中绿色的方格代表 `true`）。如果想找节点 `x` 的邻居，去扫一圈 `matrix[x][..]` 就行了。

**代码实现**

```go
// 邻接表

// 邻接矩阵
// matrix[x][y] 记录 x 是否有一条指向 y 的边
matrix [][]bool
```



### 两种存储方式的优缺点

对于邻接表，**好处是占用的空间少**。

但是，**邻接表无法快速判断两个节点是否相邻。**

比如说我想判断节点 `1` 是否和节点 `3` 相邻，我要去邻接表里 `1` 对应的邻居列表里查找 `3` 是否存在。但对于邻接矩阵就简单了，只要看看 `matrix[1][3]` 就知道了，效率高。





### 图的遍历

**各种数据结构被发明出来无非就是为了遍历和访问，所以「遍历」是所有数据结构的基础**。

图怎么遍历？还是那句话，参考多叉树，多叉树的 DFS 遍历框架如下：

```GO
/* 多叉树遍历框架 */
func traverse(root TreeNode) {
    if root == nil {
        return 
    }
    // 前序位置
    for child := range root.childern {
        traverse(child)
    }
    // 后序位置
}
```



​	**图和多叉树最大的区别是，图是可能包含环的**，你从图的某一个节点开始遍历，有可能走了一圈又回到这个节点，而树不会出现这种情况，从某个节点出发必然走到叶子节点，绝不可能回到它自身。

==所以，如果图包含环，遍历框架就要一个 `visited` 数组进行辅助==：

```go
// 记录被遍历过的节点
visited []bool
// 记录从起点到当前节点的路径
onPath  []bool

/* 图遍历框架 */
func traverse(graph Graph, s int) {
    // 由于图可能有环，因此不能像遍历树一样，设置节点nil为递归结束条件
    // 所以需要使用一个辅助数组，用来记录被遍历过的节点
    // 当节点被访问过时，递归结束
    if visited[s] {
        return 
    }
    // 经过节点 s，标记为已遍历
    visited[s] = true
    // 做选择：标记节点 s 在路径上
    onPath[s] = true
    for neighbor := range graph.neighbors(s) {
        traverse(graph, neighbor)
    }
    

}
```





#### BFS 算法

##### 思想

BFS 的核心思想应该不难理解的，就是把一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，我们写 **BFS 算法都是用「队列」这种数据结**构，每次将一个节点周围的所有节点加入队列。

BFS 相对 DFS 的最主要的区别是：**BFS 找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多。**



**BFS 出现的常见场景：**

**其问题的本质就是让你在一幅「图」中找到从起点 `start` 到终点 `target` 的最近距离，这个例子听起来很枯燥，但是 BFS 算法问题其实都是在干这个事儿**



这个广义的描述可以有各种变体，比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带「传送门」可以瞬间传送呢？

再比如说两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？

再比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？

净整些花里胡哨的，这些问题都没啥奇技淫巧，本质上就是一幅「图」，让你从一个起点，走到终点，问最短路径。这就是 BFS 的本质，框架搞清楚了直接默写就好。



##### 框架

```go
func BFS() {
    // 1. 确定起点和终点
    start, target := ...
    // 2. 使用辅助队列
    queue := []type{}
    // 2.1 图形序列化
    
	// 3. 设置标记数组，防止走回头路
    
    // 4. 从起点开始访问
    
    // 5. 遍历节点
    for len(queue) > 0 {
        sz := len(queue)
        
        for i := 0 to sz {
            if // 未被访问过
            
        }  
    }
}





```



```go
// 计算从起点 start 到终点 target 的最近距离
func BFS(start *Node, target *Node) int {
    q := []*Node{}  // 核心数据结构
    visited := map[*Node]struct{}{}  // 避免走回头路
    
    q = append(q, start)  // 将起点加入队列
    visited[start] = struct{}{}
    step := 0 // 记录扩散的步数
    
    for len(q) > 0 {
        sz := len(q)
        /* 将当前队列中的所有节点向四周扩散 */
        for i := 0; i < sz; i++ {
            cur := q[len(q)-1]
            q = q[:len(q)-1]
            /* 划重点：这里判断是否到达终点 */
            if cur == target {
                return setp
            }
            /* 将 cur 的相邻节点加入队列 */
            for _, x := range cur.adj() {
                if x not in visited {
                    q = append(q, x)
                    visited[q] = struct{}{}
                }
            }
        }
        /* 划重点：更新步数在这里 */
        step++
    }
}
```



##### 二叉树的最小高度

**题目**：[111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/submissions/)

**思路**：

怎么套到 BFS 的框架里呢？首先明确一下起点 `start` 和终点 `target` 是什么，怎么判断到达了终点？

**显然起点就是 `root` 根节点，终点就是最靠近根节点的那个「叶子节点」嘛**，叶子节点就是两个子节点都是 `null` 的节点：

这里注意这个 两个`for` 循环的配合，**第一个`for` 循环控制一层一层往下走，第二个`for` 循环利用 `sz` 变量控制从左到右遍历每一层二叉树节点**：

<img src="https://labuladong.github.io/algo/images/dijkstra/1.jpeg" alt="img" style="zoom:50%;" />

**代码**：

```go
func minDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    // 记录树的深度
    depth := 1

    // 辅助队列
    queue := []*TreeNode{root} 
    // BFS 
    for len(queue) > 0 {
        n := len(queue)
        for i := 0; i < n; i++ {
            // 出队
            q := queue[0]
            queue = queue[1:]
            if q.Left == nil && q.Right == nil {
                return depth
            }

            if q.Left != nil {
                queue = append(queue, q.Left)
            }
            if q.Right != nil {
                queue = append(queue, q.Right)
            }
        }
        depth++
    }

    return depth
}
```



##### 解开密码锁的最少次数

**题目**：[752. 打开转盘锁](https://leetcode.cn/problems/open-the-lock/submissions/)

**思路**：

**第一步，我们不管所有的限制条件，不管 `deadends` 和 `target` 的限制，就思考一个问题：如果让你设计一个算法，穷举所有可能的密码组合，你怎么做**？

穷举呗，再简单一点，如果你只转一下锁，有几种可能？总共有 4 个位置，**每个位置可以向上转，也可以向下转**，也就是有 8 种可能对吧。

比如说从 `"0000"` 开始，转一次，可以穷举出 `"1000", "9000", "0100", "0900"...` 共 8 种密码。然后，再以这 8 种密码作为基础，对每个密码再转一下，穷举出所有可能…

**仔细想想，这就可以抽象成一幅图，每个节点有 8 个相邻的节点**，又让你求最短距离，这不就是典型的 BFS 嘛，框架就可以派上用场了，先写出一个「简陋」的 BFS 框架代码再说别的：

**这段 BFS 代码已经能够穷举所有可能的密码组合了，但是显然不能完成题目，有如下问题需要解决**：

1、会走回头路。比如说我们从 `"0000"` 拨到 `"1000"`，但是等从队列拿出 `"1000"` 时，还会拨出一个 `"0000"`，这样的话会产生死循环。

2、没有终止条件，按照题目要求，我们找到 `target` 就应该结束并返回拨动的次数。

3、没有对 `deadends` 的处理，按道理这些「死亡密码」是不能出现的，也就是说你遇到这些密码的时候需要跳过。

```go
func openLock(deadends []string, target string) int {
    // 记录需要跳过的死亡密码
    deads := map[string]struct{}{}
    for _, s := range deadends {
        deads[s] = struct{}{}
    }
    // 记录已经穷举过的密码，防止走回头路
    visited := map[string]struct{}{}
    queue := []string{"0000"}
    visited["0000"] = struct{}{}
    step := 0

    for len(queue) > 0 {
        sz := len(queue)
        /* 将当前队列中的所有节点向周围扩散 */
        for i := 0; i < sz; i++ {
            q := queue[0]
            queue = queue[1:]
            /* 判断是否到达终点 */
            if _, ok := deads[q]; ok {
                continue
            }
            if q == target {
                return step
            }

            /* 将一个节点的相邻节点加入队列 */
            for j := 0; j < 4; j++ {
                up := plusOne(q, j)
                if _, ok := visited[up]; !ok {
                    queue = append(queue, up)
                    visited[up] = struct{}{}
                }
                down := minusOne(q, j)
                if _, ok := visited[down]; !ok {
                    queue = append(queue, down)
                    visited[down] = struct{}{}
                }
            }
        }
        /* 在这里增加步数 */
        step++
    }

    return -1
}


// 将s[i]向上拨动
func plusOne(s string, i int) string {
    ch := []byte(s)
    if ch[i] == '9' {
        ch[i] = '0'
    } else {
        ch[i] += 1
    }
    return string(ch)
}

// 将s[i]向下拨动
func minusOne(s string, i int) string {
    ch := []byte(s)
    if ch[i] == '0' {
        ch[i] = '9'
    } else {
        ch[i] -= 1
    }
    return string(ch)
}
```



##### 双向 BFS 优化

**统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止**。

为什么这样能够能够提升效率呢？其实从 Big O 表示法分析算法复杂度的话，它俩的最坏复杂度都是 `O(N)`，但是实际上双向 BFS 确实会快一些，我给你画两张图看一眼就明白了：

<img src="https://labuladong.github.io/algo/images/BFS/1.jpeg" alt="img" style="zoom:50%;" />

![img](https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301182311100.jpeg)

图示中的树形结构，如果终点在最底部，按照传统 BFS 算法的策略，会把整棵树的节点都搜索一遍，最后找到 `target`；而双向 BFS 其实只遍历了半棵树就出现了交集，也就是找到了最短距离。从这个例子可以直观地感受到，双向 BFS 是要比传统 BFS 高效的。

双向 BFS 还是遵循 BFS 算法框架的，只是**不再使用队列，而是使用 HashSet 方便快速判断两个集合是否有交集**。

另外的一个技巧点就是 **while 循环的最后交换 `q1` 和 `q2` 的内容**，所以只要默认扩散 `q1` 就相当于轮流扩散 `q1` 和 `q2`。

**代码**

```go
func openLock(deadends []string, target string) int {
    // 记录需要跳过的死亡密码
    deads := map[string]struct{}{}
    for _, s := range deadends {
        deads[s] = struct{}{}
    }
    // 记录已经穷举过的密码，防止走回头路
    visited := map[string]struct{}{}
    // 使用两个哈希表代替队列
    q1 := map[string]struct{}{}
    q2 := map[string]struct{}{}

    q1["0000"] = struct{}{}
    q2[target] = struct{}{}
    step := 0

    for len(q1) > 0 && len(q2) > 0 {
        if len(q1) > len(q2) {
            q1, q2 = q2, q1
        }
        // 哈希集合在遍历的过程中不能修改，用 temp 存储扩散结果
        tmp := map[string]struct{}{}
        /* 将 q1 中的所有节点向周围扩散 */
        for cur, _ := range q1 {
            /* 判断是否到达终点 */
            if _, ok := deads[cur]; ok {
                continue
            }
            if _, ok := q2[cur]; ok {
                return step
            }

            visited[cur] = struct{}{}
            /* 将一个节点的未遍历相邻节点加入集合 */
            for j := 0; j < 4; j++ {
                up := plusOne(cur, j)
                if _, ok := visited[up]; !ok {
                    tmp[up] = struct{}{}
                }
                down := minusOne(cur, j)
                if _, ok := visited[down]; !ok {
                    tmp[down] = struct{}{}
                }
            }
        }
        /* 在这里增加步数 */
        step++
        // temp 相当于 q1
        // 这里交换 q1 q2，下一轮 for 就是扩散 q2
        q1 = q2
        q2 = tmp
    }
    return -1
}


// 将s[i]向上拨动
func plusOne(s string, i int) string {
    ch := []byte(s)
    if ch[i] == '9' {
        ch[i] = '0'
    } else {
        ch[i] += 1
    }
    return string(ch)
}

// 将s[i]向下拨动
func minusOne(s string, i int) string {
    ch := []byte(s)
    if ch[i] == '0' {
        ch[i] = '9'
    } else {
        ch[i] -= 1
    }
    return string(ch)
}
```



#### BFS 算法秒杀各种智力题



**思路**：

对于这种计算最小步数的问题，我们就要敏感地想到 BFS 算法。

这个题目转化成 BFS 问题是有一些技巧的，我们面临如下问题：

1、一般的 BFS 算法，是从一个起点 `start` 开始，向终点 `target` 进行寻路，但是拼图问题不是在寻路，而是在不断交换数字，这应该怎么转化成 BFS 算法问题呢？

2、即便这个问题能够转化成 BFS 问题，如何处理起点 `start` 和终点 `target`？它们都是数组哎，把数组放进队列，套 BFS 框架，想想就比较麻烦且低效。

首先回答第一个问题，**BFS 算法并不只是一个寻路算法，而是一种暴力搜索算法**，只要涉及暴力穷举的问题，BFS 就可以用，而且可以最快地找到答案。

明白了这个道理，我们的问题就转化成了：**如何穷举出 `board` 当前局面下可能衍生出的所有局面**？这就简单了，看数字 0 的位置呗，和上下左右的数字进行交换就行了：

<img src="https://labuladong.github.io/algo/images/sliding_puzzle/3.jpeg" alt="img" style="zoom:50%;" />

这样其实就是一个 BFS 问题，每次先找到数字 0，然后和周围的数字进行交换，形成新的局面加入队列…… 当第一次到达 `target` 时，就得到了赢得游戏的最少步数。

对于第二个问题，我们这里的 `board` 仅仅是 2x3 的二维数组，所以可以压缩成一个一维字符串。**其中比较有技巧性的点在于，二维数组有「上下左右」的概念，压缩成一维后，如何得到某一个索引上下左右的索引**？

对于这道题，题目说输入的数组大小都是 2 x 3，所以我们可以直接手动写出来这个映射：

```go
    // 记录一维字符串的相邻索引
	// 对于位置0，其相邻位置为右边的1，下边的3
    neighbor := [][]int{
        {1, 3},
        {0, 2, 4},
        {1, 5},
        {0, 4},
        {3, 1, 5}, 
        {4, 2},
    }
```

**这个含义就是，在一维字符串中，索引 `i` 在二维数组中的的相邻索引为 `neighbor[i]`**

<img src="https://labuladong.github.io/algo/images/sliding_puzzle/4.jpeg" alt="img" style="zoom:50%;" />



**代码**

```go
func slidingPuzzle(board [][]int) int {
    // 将初始 board 转化为 初始字符串
    var str bytes.Buffer
    for _, bo := range board {
        for _, b := range bo {
            str.WriteString(strconv.Itoa(b))
        } 
    }
    start := str.String()

    // 记录一维字符串的相邻索引
    neighbor := [][]int{
        {1, 3},
        {0, 2, 4},
        {1, 5},
        {0, 4},
        {3, 1, 5}, 
        {4, 2},
    }
    /******* BFS 算法框架开始 *******/
    Queue := []string{}
    visit := map[string]struct{}{}
    // 从起点开始 BFS 搜索
    Queue = append(Queue, start)
    visit[start] = struct{}{}

    target := "123450"
    step := 0 
    for len(Queue) > 0 {
        sz := len(Queue) 
        for i := 0; i < sz; i++ {
            cur := Queue[0]
            Queue = Queue[1:]
            if cur == target {
                return step
            }
            // 找到数字'0'的索引
            idx := 0
            for cur[idx] != '0' {
                idx++
            }
            // 将数字 0 和相邻的数字交换位置
            for _, ne := range neighbor[idx] {
                byte_cur := []byte(cur)
                byte_cur[ne], byte_cur[idx] = byte_cur[idx], byte_cur[ne]
                new_board := string(byte_cur)
                // 防止走回头路
                if _, ok := visit[new_board]; !ok {
                    Queue = append(Queue, new_board)
                    visit[new_board] = struct{}{}
                }
                
            }
        }
        step++
    }

    return -1
}
```

