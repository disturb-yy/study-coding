# 动态规划

### 概念

##### 1 动态规划的一般求解形式 —— 求最值

##### 2 动态规划核心问题

​	求解动态规划的核⼼问题是**穷举**，然后在穷举的答案中找**最值**。但可能会存在一些重复求解的问题（即重复子问题）。

##### 3 动态规划三要素

- 重复子问题

  在穷举过程中，求解的问题重复出现，如果每次出现都重新求解，可能会导致很多的重复计算，因此动态规划需要去优化穷举的过程，常见的操作就是引进一个**【备忘录】**或者**【DP table】**

- 最优子结构

  如果问题的最优解是由其子问题的最优解来构造，则称该问题具有最优子结构性质。**【即原问题的最优解可由子问题的最优解得到】**，因此动态规划求解的问题必须具有**无后效性**，即我们只求解每个阶段的最优解的结果，而不关心其求解的过程。

- 状态转移方程

  阶段与阶段之间的联系

  

  ​	

### 思想

##### 1 动态规划的思想实质 

​	分治思想（**分解问题**）和解决冗余（**查表**）。 

##### 2 与分治法类似的是

   将原问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。

##### 3 与分治法不同的是

   经分解的子问题**往往不是互相独立的**。若用分治法来解，有些共同部分（子问题或子子问题）被重复计算了很多次。

​	如果能够保存已解决的子问题的答案，在需要时再查找，这样就可以避免重复计算、节省时间。动态规划法**用一个表来记录所有已解的子问题的答案**。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表方式。

##### 4 如何写出状态转移方程

- 明确**base case**
- 明确「状态」
- 明确「选择」
- 定义 `dp` 数组/函数的含义
- 确定`dp`数组`（dp table）`以及下标的含义
- 确定递推公式
- `dp`数组如何初始化
- 确定遍历顺序
- 举例推导`dp`数组



### 动态规划应该如何debug

相信动规的题目，很大部分同学都是这样做的。

看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp数组的初始化，递推公式，遍历顺序，处于一种黑盒的理解状态。

写动规题目，代码出问题很正常！

**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！**

一些同学对于dp的学习是黑盒的状态，就是不清楚dp数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。

这是一个很不好的习惯！

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。

如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。

如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

**这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了**。



## 





<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/202301211646923.jpeg" alt="img" style="zoom:50%;" />



### DP解法

#### 一 经验解法

##### 1 我们是如何确定本题可以使用动态规划来解决的？

​	通常我们要从**「有无后效性」**进行入手分析。

​	**如果对于某个状态，我们可以只关注状态的值，而不需要关注状态是如何转移过来的话，那么这就是一个无后效性的问题，**可以考虑使用 DP 解决。另外一个更加实在的技巧，我们还可以通过 **数据范围** 来猜测是不是可以用 DP 来做。

​	因为 DP 是一个递推的过程，因此如果数据范围是 10^5 ~10^6的话，可以考虑是不是可以使用一维 DP 来解决；如果数据范围是 10^2-10^3的话，可以考虑是不是可以使用二维 DP 来做 ...



#### 二 技巧解法

​	使用这种技巧，你将不需要去猜「状态定义」和根据「状态定义」推导「状态转移方程」	

​	如下面的例子：

我们重点关注下我们的 DFS 方法签名设计：

```go
dfs(ls []int, u int, end int, fuel int) int {}
```


其中，ls 参数和 end 参数分别代表源输入的 locations 和 finish，在整个 DFS 过程都不会变化，属于**不变参数**。

而 u 参数和 fuel 参数则是代表了 DFS 过程中的当前位置和当前油量，属于**变化参数**。

**因此我们可以定一个 f[][] 二维数组，来分别表示两个可变参数。**

- 第一维代表当前位置（对应 locations 数组的下标），

- 第二维代表当前剩余油量。二维数组中存储的就是我们的 DFS 方法的返回值（路径数量）。

**同时结合题意，不难得知维度的取值范围：**

- 第一维的取值范围为 [0, locations.length)
- 第二维的取值范围为 [0, fuel]。做完这一步的”翻译“工作，我们就得到了「动态规划」的**「状态定义」**了。

**f\[i][j]代表从位置 i 出发，当前剩余油量为 j 的前提下，到达目的地的路径数量。**

不知道你是否发现，这个「状态定义」和我们「记忆化搜索」中的缓存器的定义是一致的。

接下来我们要从 DFS 中”翻译“出「状态转移方程」。所谓的「状态转移方程」其实就是指如何从一个状态转移到另外一个状态。

而我们的 DFS 主逻辑就是完成这个转移的。**DFS 中的主逻辑很简单：枚举所有的位置，看从当前位置 u 出发，可以到达的位置有哪些。**

于是我们很容易就可以得出状态转移方程：

​						**f\[i][fuel]=f\[i][fuel]+f\[k][fuel-need]**

k 代表计算位置 i 油量 fuel 的状态时枚举的「下一位置」，need 代表从 i 到达 k 需要的油量。从状态转移方程可以发现，在计算 f\[i][fuel] 的时候依赖于 f\[k][fuel-need]。其中 i 和 k 并无严格的大小关系，而 fuel 和 fuel-need 具有严格的大小关系（fuel >= fuel-need）。

**因此我们需要先从小到大枚举油量这一维。**





### 常见问题

##### 1 对状态转移的要求是什么？

​	我们的状态转移是要做到「不漏」还是「不重不漏」取决于问题本身：

- 如果是**求最值**的话，我们只需要确保**「不漏**」即可，因为重复不影响结果。
- 如果是**求方案数**的话，我们需要确保**「不重不漏」**。



##### 2 我们是如何分析动态规划的时间复杂度的？

​	对于动态规划的复杂度/计算量分析，**有多少个状态，复杂度/计算量就是多少**。

​	因此一维 DP 的复杂度通常是线性的 O(n)，而二维 DP 的复杂度通常是平方的 O(n^2)。



##### 3 如何确定「状态定义」呢？

​	通常我们会根据「结尾」或「答案」来猜 DP 的状态定义。所谓的「结尾」通常就是指「最后一步」。对于本题，我们结合两者可以猜一个 DP 状态： f\[i][j]代表到达某个点的最小路径和。那么 min(f\[n-1][i])（最后一行的每列的路径和的最小值）就是答案。





### 例子

#### 1 斐波那契数列 —— 理解重复子问题

##### 1）暴力递归

```go
func fib(n int) int {
    if n == 1 || n == 2 {
        return 1
    }
    return fib(n-1) + fib(n-2)
}
```

根据递归思想画出上述的递归树：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/image-20221222233955043.png" alt="image-20221222233955043" style="zoom:50%;" />

​		

**递归算法的时间复杂度怎么计算？子问题个数乘以解决⼀个⼦问题需要的时间。**

子问题个数，即递归树中节点的总数。显然⼆叉树节点总数为指数级别，所以⼦问题个数为 O(2^n)。

解决⼀个⼦问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) ⼀个加法操作，时间为 O(1)。

所以，这个算法的时间复杂度为 O(2^n)，指数级别，爆炸。

**观察递归树，很明显发现了算法低效的原因：**存在大量重复计算，比如f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨⼤，多算⼀遍，会耗费巨⼤的时间。这就是动态规划问题的第一个性质，也是其要解决的问题：**【重复子问题】**

##### 2）改进：带备忘录的递归 —— 自顶向下法

​	对于重复子问题，一个很容易想到的方法就是使用一个备忘录记录已经求解的子问题的答案，当用到的时候，直接从备忘录中取出即可。其算法如下：

```go
func fib(n int) int {
    memo := make([]int, n+1)
    var f func(x int) int
    f = func(x int) int {
        if x == 1 || x == 2 {
            return x
        }
        if memo[x] != 0 {
            return memo[x]
        }
        memo[x] = f(x-1) + f(x-2)
        return memo[x]
    }
    return f(n)
}
```

根据算法思想，可画出如下的递归树：

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/image-20221222235557188.png" alt="image-20221222235557188" style="zoom:50%;" />

**复杂度计算**

- 时间：每个节点计算一次，因此是O(n)
- 空间：备忘录O(n) + 递归栈O(n) ——> O(n)



##### 3）改进：dp数组的迭代解法 —— 自底向上

​	将备忘录改为一张表，其可以查询子问题的结果，记为**DP table**。其算法如下：

```go
func fib(n int) int {
    dp := make([]int, n+1)
    dp[1], dp[2] = 1, 1
    for i := 3; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}
```

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/image-20221223000812484.png" alt="image-20221223000812484" style="zoom:50%;" />

##### 4）状态转移方程

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/image-20221223000949072.png" alt="image-20221223000949072" style="zoom:50%;" />

​    为啥叫「状态转移⽅程」？为了听起来⾼端。你把 f(n) 想做⼀个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移⽽来，这就叫状态转移，仅此⽽已。

​    你会发现，上⾯的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可⻅列出「状态转移⽅程」的重要性，它是解决问题的核⼼。

 	很容易发现，**【其实状态转移方程直接代表着暴力解法】**。**千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移⽅程**，即这个暴力解。优化⽅法⽆⾮是⽤备忘录或者 DP table，再⽆奥妙可⾔。

##### 5）算法优化

​	根据斐波那契数列的状态转移⽅程，当前状态只和之前的两个状态有关，其实并不需要那么长的⼀个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进⼀步优化，把空间复杂度降为 O(1)：

```go
func fib(n int) int {
    if n == 1 || n == 2 {
        return n
    }
    pre, cur := 1, 1
    for i := 3; i <= n; i++ {
        pre, cur = cur, pre+cur
    }
    return cur
}
```



#### 2 凑零钱问题 —— 理解最优子结构

##### 1）题⽬

​	给你 k 种⾯值的硬币，⾯值分别为 c1, c2 ... ck ，每种硬币的数量无限，再给⼀个总金额 amount ，问你**最少**需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。

​	比如说 k = 3 ，面值分别为 1，2，5，总⾦额 amount = 11 。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。

##### 2）暴力递归

```go
func coinChange(coins []int, amount int) int {
    var i int
    // 找到不大于amount的最大面值
    for i = len(coins)-1; i >= 0; i-- {
        if coins[i] <= amount {
            break
        }
    }
    sum := 0
    for j := i; j >= 0; j-- {
        sum += amount / coins[j]
        amount /= coins[i]
        if amount == 0 {
            break
        }
    }
    return sum
}
```



**为什么说它符合最优子结构呢？**

​	比如你想求 amount =11 时的最少硬币数（原问题），如果你知道凑出 amount = 10 的最少硬币数（⼦问题），你只需要把⼦问题的答案加⼀（再选⼀枚⾯值为 1 的硬币）就是原问题的答案，**【因为硬币的数量是没有限制的，⼦问题之间没有相互制，是互相独立的】。**

那么，既然知道了这是个动态规划问题，就要思考**如何列出正确的状态转移方程？**

- **先确定「状态」**，也就是原问题和子问题中变化的变量。由于硬币数量⽆限，**所以唯⼀的状态就是目标金额 amount** 。

- **然后确定dp数组的含义**：当前金额为n，至少需要**dp[n]个硬币才能凑出该金额**。

- **然后确定【选择】并择优**：也就是对于每个状态，**可以做出什么选择改变当前状态**。具体到这个问题，无论当前的目标金额是多少，选择就是从面额列表coins中选择一个硬币，然后目标金额就会减少。

  ```go
  # 伪代码
  def coinChange(coins []int, amount int) int {
      # 函数功能：要凑出金额n，需要dp[n]个硬币
      def dp[n]:
      	# 做选择，选择硬币最少的那个结果
      	for coin in coins:
      		// 选择coin硬币，其操作次数是面额为n-coin的金额所需操作数+1
      		res = min(res, dp[n-coin]+1)
      	return res
      # 我们所求问题
      return dp[amount]
  }
  ```

- 明确**初始状态**：当金额为0时，所需硬币数量为0，即dp[0] = 0，当目标金额小于0时，无解

​	以上代码的数学形式就是状态转移方程

<img src="https://raw.githubusercontent.com/disturb-yy/study-coding/main/img/image-20221223004226175.png" alt="image-20221223004226175" style="zoom:50%;" />

##### 3）改进 —— 带备忘录的递归

```go
func coinChange(coins []int, amount int) int {
    memo := []int{}
	// 当前金额为n，所需的最小硬币数量
    var subProblem func(n int) int 
    subProblem = func(n int) int {
		if memo[n] != 0 {
			return memo[n]
		}
		if n < 0 { return -1 }
		if n == 0 { return 0 }
		ans := -1
		for _, coin := range coins {
			if memo[n-coin] == -1 {
				continue
			}
			ans = min(ans, memo[n-coin]+1)
		}
		memo[n] = ans
		return memo[n]
	}
	return subProblem(amount)
}
```

##### 4）dp数组的迭代解法 —— 自底向上

```go
func coinChange(coins []int, amount int) int {
	if amount < 0 { return -1 }
	if amount == 0 { return 0 }
	dp := make([]int, amount+1)  // dp[0] = 0
	for i := 1; i <= amount; i++ {
		// 当前金额为i
		for _, coin := range coins {
			if i - coin < 0 { continue }
			dp[i] = min(dp[i], dp[i-coin]+1)
		}
	}
	return dp[amount]
}
```

> **计算机解决问题其实没有任何奇淫巧计，它唯一解决办法就是*穷举***，穷举所有可能性。算法设计无法就是**【先思考“如何穷举”，再追求”如何聪明的穷举“】**。列出状态转移方程，其实质就是在解决**”如何穷举的问题“**。之所以说动态规划难，一是因为很多穷举需要递归实现，二是因为有的问题本身解空间复杂，很难在规定时间内穷举完成。而引入”备忘录、DP table“就是在追求**”如何聪明的穷举“**。用空间换时间的思想，是降低时间复杂度的不二法门，除此之外，试问，还能玩出什么花样？





### 【注释】

1. 阶段：把所给的问题的求解过程恰当地划分为若干个相互联系的阶段。
2. 状态：状态表示每个阶段开始时，问题的客观状况。状态既是该阶段的某个起点，又是前一个阶段的某个终点。通常一个阶段有若干个状态。
3. 无后效性：如果某阶段状态给定后，则该阶段以后过程的发展不受该阶段以前各阶段状态的影响，也就是说状态具有马尔科夫性。**【即之前的决策不会影响之后的决策】**，如一颗在(2,3)的棋子，我们不关心它之前是如何走到当前位置，也不会影响到我之后的决策
4. 有后效性：与无后效性相反，如移动一颗棋子，但是**【棋子不能走重复的格子】**，此时之前的决策对后面的决策就有影响。